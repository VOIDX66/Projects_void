Grammar:

Rule 0     S' -> program
Rule 1     program -> decl _1_decl_repeat
Rule 2     _1_decl_repeat -> _1_decl_items
Rule 3     _1_decl_repeat -> <empty>
Rule 4     _1_decl_items -> _1_decl_items _1_decl_item
Rule 5     _1_decl_items -> _1_decl_item
Rule 6     _1_decl_item -> decl
Rule 7     decl -> func_decl
Rule 8     decl -> var_decl
Rule 9     var_decl -> type_spec IDENT [ ] ;
Rule 10    var_decl -> type_spec IDENT ;
Rule 11    type_spec -> FLOAT
Rule 12    type_spec -> INT
Rule 13    type_spec -> BOOL
Rule 14    type_spec -> VOID
Rule 15    func_decl -> type_spec IDENT ( params ) compound_stmt
Rule 16    params -> VOID
Rule 17    params -> param_list
Rule 18    param_list -> param _2_0x2c_param_repeat
Rule 19    _2_0x2c_param_repeat -> _2_0x2c_param_items
Rule 20    _2_0x2c_param_repeat -> <empty>
Rule 21    _2_0x2c_param_items -> _2_0x2c_param_items _2_0x2c_param_item
Rule 22    _2_0x2c_param_items -> _2_0x2c_param_item
Rule 23    _2_0x2c_param_item -> , param
Rule 24    param -> type_spec IDENT [ ]
Rule 25    param -> type_spec IDENT
Rule 26    compound_stmt -> { local_decls stmt_list }
Rule 27    local_decls -> empty
Rule 28    local_decls -> local_decl
Rule 29    local_decl -> type_spec IDENT [ ] ;
Rule 30    local_decl -> type_spec IDENT ;
Rule 31    stmt_list -> _3_stmt_repeat
Rule 32    _3_stmt_repeat -> _3_stmt_items
Rule 33    _3_stmt_repeat -> <empty>
Rule 34    _3_stmt_items -> _3_stmt_items _3_stmt_item
Rule 35    _3_stmt_items -> _3_stmt_item
Rule 36    _3_stmt_item -> stmt
Rule 37    stmt -> break_stmt
Rule 38    stmt -> return_stmt
Rule 39    stmt -> while_stmt
Rule 40    stmt -> if_stmt
Rule 41    stmt -> compound_stmt
Rule 42    stmt -> expr_stmt
Rule 43    expr_stmt -> ;
Rule 44    expr_stmt -> expr ;
Rule 45    while_stmt -> WHILE ( expr ) stmt
Rule 46    if_stmt -> IF ( expr ) stmt  [precedence=nonassoc, level=1]
Rule 47    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=nonassoc, level=2]
Rule 48    return_stmt -> RETURN _4_expr_optional ;
Rule 49    _4_expr_optional -> expr
Rule 50    _4_expr_optional -> <empty>
Rule 51    break_stmt -> CONTINUE ;
Rule 52    break_stmt -> BREAK ;
Rule 53    expr -> NEW type_spec [ expr ]
Rule 54    expr -> STRING
Rule 55    expr -> FLOAT_LIT
Rule 56    expr -> INT_LIT
Rule 57    expr -> BOOL_LIT
Rule 58    expr -> IDENT . SIZE
Rule 59    expr -> IDENT ( args )
Rule 60    expr -> IDENT [ expr ]
Rule 61    expr -> IDENT
Rule 62    expr -> ( expr )
Rule 63    expr -> + expr  [precedence=right, level=10]
Rule 64    expr -> - expr  [precedence=right, level=10]
Rule 65    expr -> ! expr  [precedence=right, level=10]
Rule 66    expr -> expr % expr  [precedence=left, level=9]
Rule 67    expr -> expr / expr  [precedence=left, level=9]
Rule 68    expr -> expr * expr  [precedence=left, level=9]
Rule 69    expr -> expr - expr  [precedence=left, level=8]
Rule 70    expr -> expr + expr  [precedence=left, level=8]
Rule 71    expr -> expr > expr  [precedence=left, level=7]
Rule 72    expr -> expr GE expr  [precedence=left, level=7]
Rule 73    expr -> expr < expr  [precedence=left, level=7]
Rule 74    expr -> expr LE expr  [precedence=left, level=7]
Rule 75    expr -> expr NE expr  [precedence=left, level=6]
Rule 76    expr -> expr EQ expr  [precedence=left, level=6]
Rule 77    expr -> expr AND expr  [precedence=left, level=5]
Rule 78    expr -> expr OR expr  [precedence=left, level=4]
Rule 79    expr -> IDENT [ expr ] = expr  [precedence=right, level=3]
Rule 80    expr -> IDENT = expr  [precedence=right, level=3]
Rule 81    args -> empty
Rule 82    args -> arg_list
Rule 83    arg_list -> expr _5_0x2c_expr_optional
Rule 84    _5_0x2c_expr_optional -> , expr
Rule 85    _5_0x2c_expr_optional -> <empty>
Rule 86    empty -> <empty>

Unused terminals:

    CLASS
    CHAR
    DOUBLE

Terminals, with rules where they appear:

!                    : 65
%                    : 66
(                    : 15 45 46 47 59 62
)                    : 15 45 46 47 59 62
*                    : 68
+                    : 63 70
,                    : 23 84
-                    : 64 69
.                    : 58
/                    : 67
;                    : 9 10 29 30 43 44 48 51 52
<                    : 73
=                    : 79 80
>                    : 71
AND                  : 77
BOOL                 : 13
BOOL_LIT             : 57
BREAK                : 52
CHAR                 : 
CLASS                : 
CONTINUE             : 51
DOUBLE               : 
ELSE                 : 47
EQ                   : 76
FLOAT                : 11
FLOAT_LIT            : 55
GE                   : 72
IDENT                : 9 10 15 24 25 29 30 58 59 60 61 79 80
IF                   : 46 47
INT                  : 12
INT_LIT              : 56
LE                   : 74
NE                   : 75
NEW                  : 53
OR                   : 78
RETURN               : 48
SIZE                 : 58
STRING               : 54
VOID                 : 14 16
WHILE                : 45
[                    : 9 24 29 53 60 79
]                    : 9 24 29 53 60 79
error                : 
{                    : 26
}                    : 26

Nonterminals, with rules where they appear:

_1_decl_item         : 4 5
_1_decl_items        : 2 4
_1_decl_repeat       : 1
_2_0x2c_param_item   : 21 22
_2_0x2c_param_items  : 19 21
_2_0x2c_param_repeat : 18
_3_stmt_item         : 34 35
_3_stmt_items        : 32 34
_3_stmt_repeat       : 31
_4_expr_optional     : 48
_5_0x2c_expr_optional : 83
arg_list             : 82
args                 : 59
break_stmt           : 37
compound_stmt        : 15 41
decl                 : 1 6
empty                : 27 81
expr                 : 44 45 46 47 49 53 60 62 63 64 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 74 75 75 76 76 77 77 78 78 79 79 80 83 84
expr_stmt            : 42
func_decl            : 7
if_stmt              : 40
local_decl           : 28
local_decls          : 26
param                : 18 23
param_list           : 17
params               : 15
program              : 0
return_stmt          : 38
stmt                 : 36 45 46 47 47
stmt_list            : 26
type_spec            : 9 10 15 24 25 29 30 53
var_decl             : 8
while_stmt           : 39


state 0

    (0) S' -> . program
    (1) program -> . decl _1_decl_repeat
    (7) decl -> . func_decl
    (8) decl -> . var_decl
    (15) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (9) var_decl -> . type_spec IDENT [ ] ;
    (10) var_decl -> . type_spec IDENT ;
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    program                        shift and go to state 1
    decl                           shift and go to state 2
    func_decl                      shift and go to state 3
    var_decl                       shift and go to state 4
    type_spec                      shift and go to state 5

state 1

    (0) S' -> program .


state 2

    (1) program -> decl . _1_decl_repeat
    (2) _1_decl_repeat -> . _1_decl_items
    (3) _1_decl_repeat -> .
    (4) _1_decl_items -> . _1_decl_items _1_decl_item
    (5) _1_decl_items -> . _1_decl_item
    (6) _1_decl_item -> . decl
    (7) decl -> . func_decl
    (8) decl -> . var_decl
    (15) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (9) var_decl -> . type_spec IDENT [ ] ;
    (10) var_decl -> . type_spec IDENT ;
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    $end            reduce using rule 3 (_1_decl_repeat -> .)
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    decl                           shift and go to state 10
    _1_decl_repeat                 shift and go to state 11
    _1_decl_items                  shift and go to state 12
    _1_decl_item                   shift and go to state 13
    func_decl                      shift and go to state 3
    var_decl                       shift and go to state 4
    type_spec                      shift and go to state 5

state 3

    (7) decl -> func_decl .
    FLOAT           reduce using rule 7 (decl -> func_decl .)
    INT             reduce using rule 7 (decl -> func_decl .)
    BOOL            reduce using rule 7 (decl -> func_decl .)
    VOID            reduce using rule 7 (decl -> func_decl .)
    $end            reduce using rule 7 (decl -> func_decl .)


state 4

    (8) decl -> var_decl .
    FLOAT           reduce using rule 8 (decl -> var_decl .)
    INT             reduce using rule 8 (decl -> var_decl .)
    BOOL            reduce using rule 8 (decl -> var_decl .)
    VOID            reduce using rule 8 (decl -> var_decl .)
    $end            reduce using rule 8 (decl -> var_decl .)


state 5

    (15) func_decl -> type_spec . IDENT ( params ) compound_stmt
    (9) var_decl -> type_spec . IDENT [ ] ;
    (10) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 14


state 6

    (11) type_spec -> FLOAT .
    IDENT           reduce using rule 11 (type_spec -> FLOAT .)
    [               reduce using rule 11 (type_spec -> FLOAT .)


state 7

    (12) type_spec -> INT .
    IDENT           reduce using rule 12 (type_spec -> INT .)
    [               reduce using rule 12 (type_spec -> INT .)


state 8

    (13) type_spec -> BOOL .
    IDENT           reduce using rule 13 (type_spec -> BOOL .)
    [               reduce using rule 13 (type_spec -> BOOL .)


state 9

    (14) type_spec -> VOID .
    IDENT           reduce using rule 14 (type_spec -> VOID .)
    [               reduce using rule 14 (type_spec -> VOID .)


state 10

    (6) _1_decl_item -> decl .
    FLOAT           reduce using rule 6 (_1_decl_item -> decl .)
    INT             reduce using rule 6 (_1_decl_item -> decl .)
    BOOL            reduce using rule 6 (_1_decl_item -> decl .)
    VOID            reduce using rule 6 (_1_decl_item -> decl .)
    $end            reduce using rule 6 (_1_decl_item -> decl .)


state 11

    (1) program -> decl _1_decl_repeat .
    $end            reduce using rule 1 (program -> decl _1_decl_repeat .)


state 12

    (2) _1_decl_repeat -> _1_decl_items .
    (4) _1_decl_items -> _1_decl_items . _1_decl_item
    (6) _1_decl_item -> . decl
    (7) decl -> . func_decl
    (8) decl -> . var_decl
    (15) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (9) var_decl -> . type_spec IDENT [ ] ;
    (10) var_decl -> . type_spec IDENT ;
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    $end            reduce using rule 2 (_1_decl_repeat -> _1_decl_items .)
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    _1_decl_item                   shift and go to state 15
    decl                           shift and go to state 10
    func_decl                      shift and go to state 3
    var_decl                       shift and go to state 4
    type_spec                      shift and go to state 5

state 13

    (5) _1_decl_items -> _1_decl_item .
    FLOAT           reduce using rule 5 (_1_decl_items -> _1_decl_item .)
    INT             reduce using rule 5 (_1_decl_items -> _1_decl_item .)
    BOOL            reduce using rule 5 (_1_decl_items -> _1_decl_item .)
    VOID            reduce using rule 5 (_1_decl_items -> _1_decl_item .)
    $end            reduce using rule 5 (_1_decl_items -> _1_decl_item .)


state 14

    (15) func_decl -> type_spec IDENT . ( params ) compound_stmt
    (9) var_decl -> type_spec IDENT . [ ] ;
    (10) var_decl -> type_spec IDENT . ;
    (               shift and go to state 16
    [               shift and go to state 17
    ;               shift and go to state 18


state 15

    (4) _1_decl_items -> _1_decl_items _1_decl_item .
    FLOAT           reduce using rule 4 (_1_decl_items -> _1_decl_items _1_decl_item .)
    INT             reduce using rule 4 (_1_decl_items -> _1_decl_items _1_decl_item .)
    BOOL            reduce using rule 4 (_1_decl_items -> _1_decl_items _1_decl_item .)
    VOID            reduce using rule 4 (_1_decl_items -> _1_decl_items _1_decl_item .)
    $end            reduce using rule 4 (_1_decl_items -> _1_decl_items _1_decl_item .)


state 16

    (15) func_decl -> type_spec IDENT ( . params ) compound_stmt
    (16) params -> . VOID
    (17) params -> . param_list
    (18) param_list -> . param _2_0x2c_param_repeat
    (24) param -> . type_spec IDENT [ ]
    (25) param -> . type_spec IDENT
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    VOID            shift and go to state 21
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8

    type_spec                      shift and go to state 19
    params                         shift and go to state 20
    param_list                     shift and go to state 22
    param                          shift and go to state 23

state 17

    (9) var_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 24


state 18

    (10) var_decl -> type_spec IDENT ; .
    FLOAT           reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 10 (var_decl -> type_spec IDENT ; .)


state 19

    (24) param -> type_spec . IDENT [ ]
    (25) param -> type_spec . IDENT
    IDENT           shift and go to state 25


state 20

    (15) func_decl -> type_spec IDENT ( params . ) compound_stmt
    )               shift and go to state 26


state 21

    (16) params -> VOID .
    (14) type_spec -> VOID .
    )               reduce using rule 16 (params -> VOID .)
    IDENT           reduce using rule 14 (type_spec -> VOID .)


state 22

    (17) params -> param_list .
    )               reduce using rule 17 (params -> param_list .)


state 23

    (18) param_list -> param . _2_0x2c_param_repeat
    (19) _2_0x2c_param_repeat -> . _2_0x2c_param_items
    (20) _2_0x2c_param_repeat -> .
    (21) _2_0x2c_param_items -> . _2_0x2c_param_items _2_0x2c_param_item
    (22) _2_0x2c_param_items -> . _2_0x2c_param_item
    (23) _2_0x2c_param_item -> . , param
    )               reduce using rule 20 (_2_0x2c_param_repeat -> .)
    ,               shift and go to state 30

    _2_0x2c_param_repeat           shift and go to state 27
    _2_0x2c_param_items            shift and go to state 28
    _2_0x2c_param_item             shift and go to state 29

state 24

    (9) var_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 31


state 25

    (24) param -> type_spec IDENT . [ ]
    (25) param -> type_spec IDENT .
    [               shift and go to state 32
    ,               reduce using rule 25 (param -> type_spec IDENT .)
    )               reduce using rule 25 (param -> type_spec IDENT .)


state 26

    (15) func_decl -> type_spec IDENT ( params ) . compound_stmt
    (26) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 34

    compound_stmt                  shift and go to state 33

state 27

    (18) param_list -> param _2_0x2c_param_repeat .
    )               reduce using rule 18 (param_list -> param _2_0x2c_param_repeat .)


state 28

    (19) _2_0x2c_param_repeat -> _2_0x2c_param_items .
    (21) _2_0x2c_param_items -> _2_0x2c_param_items . _2_0x2c_param_item
    (23) _2_0x2c_param_item -> . , param
    )               reduce using rule 19 (_2_0x2c_param_repeat -> _2_0x2c_param_items .)
    ,               shift and go to state 30

    _2_0x2c_param_item             shift and go to state 35

state 29

    (22) _2_0x2c_param_items -> _2_0x2c_param_item .
    ,               reduce using rule 22 (_2_0x2c_param_items -> _2_0x2c_param_item .)
    )               reduce using rule 22 (_2_0x2c_param_items -> _2_0x2c_param_item .)


state 30

    (23) _2_0x2c_param_item -> , . param
    (24) param -> . type_spec IDENT [ ]
    (25) param -> . type_spec IDENT
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    param                          shift and go to state 36
    type_spec                      shift and go to state 19

state 31

    (9) var_decl -> type_spec IDENT [ ] ; .
    FLOAT           reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    $end            reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)


state 32

    (24) param -> type_spec IDENT [ . ]
    ]               shift and go to state 37


state 33

    (15) func_decl -> type_spec IDENT ( params ) compound_stmt .
    FLOAT           reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    INT             reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    BOOL            reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    VOID            reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    $end            reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)


state 34

    (26) compound_stmt -> { . local_decls stmt_list }
    (27) local_decls -> . empty
    (28) local_decls -> . local_decl
    (86) empty -> .
    (29) local_decl -> . type_spec IDENT [ ] ;
    (30) local_decl -> . type_spec IDENT ;
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    CONTINUE        reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    {               reduce using rule 86 (empty -> .)
    ;               reduce using rule 86 (empty -> .)
    NEW             reduce using rule 86 (empty -> .)
    STRING          reduce using rule 86 (empty -> .)
    FLOAT_LIT       reduce using rule 86 (empty -> .)
    INT_LIT         reduce using rule 86 (empty -> .)
    BOOL_LIT        reduce using rule 86 (empty -> .)
    IDENT           reduce using rule 86 (empty -> .)
    (               reduce using rule 86 (empty -> .)
    +               reduce using rule 86 (empty -> .)
    -               reduce using rule 86 (empty -> .)
    !               reduce using rule 86 (empty -> .)
    }               reduce using rule 86 (empty -> .)
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    local_decls                    shift and go to state 38
    empty                          shift and go to state 39
    local_decl                     shift and go to state 40
    type_spec                      shift and go to state 41

state 35

    (21) _2_0x2c_param_items -> _2_0x2c_param_items _2_0x2c_param_item .
    ,               reduce using rule 21 (_2_0x2c_param_items -> _2_0x2c_param_items _2_0x2c_param_item .)
    )               reduce using rule 21 (_2_0x2c_param_items -> _2_0x2c_param_items _2_0x2c_param_item .)


state 36

    (23) _2_0x2c_param_item -> , param .
    ,               reduce using rule 23 (_2_0x2c_param_item -> , param .)
    )               reduce using rule 23 (_2_0x2c_param_item -> , param .)


state 37

    (24) param -> type_spec IDENT [ ] .
    ,               reduce using rule 24 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 24 (param -> type_spec IDENT [ ] .)


state 38

    (26) compound_stmt -> { local_decls . stmt_list }
    (31) stmt_list -> . _3_stmt_repeat
    (32) _3_stmt_repeat -> . _3_stmt_items
    (33) _3_stmt_repeat -> .
    (34) _3_stmt_items -> . _3_stmt_items _3_stmt_item
    (35) _3_stmt_items -> . _3_stmt_item
    (36) _3_stmt_item -> . stmt
    (37) stmt -> . break_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . if_stmt
    (41) stmt -> . compound_stmt
    (42) stmt -> . expr_stmt
    (51) break_stmt -> . CONTINUE ;
    (52) break_stmt -> . BREAK ;
    (48) return_stmt -> . RETURN _4_expr_optional ;
    (45) while_stmt -> . WHILE ( expr ) stmt
    (46) if_stmt -> . IF ( expr ) stmt
    (47) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (26) compound_stmt -> . { local_decls stmt_list }
    (43) expr_stmt -> . ;
    (44) expr_stmt -> . expr ;
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    }               reduce using rule 33 (_3_stmt_repeat -> .)
    CONTINUE        shift and go to state 53
    BREAK           shift and go to state 55
    RETURN          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 60
    {               shift and go to state 34
    ;               shift and go to state 54
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    stmt_list                      shift and go to state 42
    _3_stmt_repeat                 shift and go to state 43
    _3_stmt_items                  shift and go to state 44
    _3_stmt_item                   shift and go to state 45
    stmt                           shift and go to state 46
    break_stmt                     shift and go to state 47
    return_stmt                    shift and go to state 48
    while_stmt                     shift and go to state 49
    if_stmt                        shift and go to state 50
    compound_stmt                  shift and go to state 51
    expr_stmt                      shift and go to state 52
    expr                           shift and go to state 59

state 39

    (27) local_decls -> empty .
    CONTINUE        reduce using rule 27 (local_decls -> empty .)
    BREAK           reduce using rule 27 (local_decls -> empty .)
    RETURN          reduce using rule 27 (local_decls -> empty .)
    WHILE           reduce using rule 27 (local_decls -> empty .)
    IF              reduce using rule 27 (local_decls -> empty .)
    {               reduce using rule 27 (local_decls -> empty .)
    ;               reduce using rule 27 (local_decls -> empty .)
    NEW             reduce using rule 27 (local_decls -> empty .)
    STRING          reduce using rule 27 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 27 (local_decls -> empty .)
    INT_LIT         reduce using rule 27 (local_decls -> empty .)
    BOOL_LIT        reduce using rule 27 (local_decls -> empty .)
    IDENT           reduce using rule 27 (local_decls -> empty .)
    (               reduce using rule 27 (local_decls -> empty .)
    +               reduce using rule 27 (local_decls -> empty .)
    -               reduce using rule 27 (local_decls -> empty .)
    !               reduce using rule 27 (local_decls -> empty .)
    }               reduce using rule 27 (local_decls -> empty .)


state 40

    (28) local_decls -> local_decl .
    CONTINUE        reduce using rule 28 (local_decls -> local_decl .)
    BREAK           reduce using rule 28 (local_decls -> local_decl .)
    RETURN          reduce using rule 28 (local_decls -> local_decl .)
    WHILE           reduce using rule 28 (local_decls -> local_decl .)
    IF              reduce using rule 28 (local_decls -> local_decl .)
    {               reduce using rule 28 (local_decls -> local_decl .)
    ;               reduce using rule 28 (local_decls -> local_decl .)
    NEW             reduce using rule 28 (local_decls -> local_decl .)
    STRING          reduce using rule 28 (local_decls -> local_decl .)
    FLOAT_LIT       reduce using rule 28 (local_decls -> local_decl .)
    INT_LIT         reduce using rule 28 (local_decls -> local_decl .)
    BOOL_LIT        reduce using rule 28 (local_decls -> local_decl .)
    IDENT           reduce using rule 28 (local_decls -> local_decl .)
    (               reduce using rule 28 (local_decls -> local_decl .)
    +               reduce using rule 28 (local_decls -> local_decl .)
    -               reduce using rule 28 (local_decls -> local_decl .)
    !               reduce using rule 28 (local_decls -> local_decl .)
    }               reduce using rule 28 (local_decls -> local_decl .)


state 41

    (29) local_decl -> type_spec . IDENT [ ] ;
    (30) local_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 70


state 42

    (26) compound_stmt -> { local_decls stmt_list . }
    }               shift and go to state 71


state 43

    (31) stmt_list -> _3_stmt_repeat .
    }               reduce using rule 31 (stmt_list -> _3_stmt_repeat .)


state 44

    (32) _3_stmt_repeat -> _3_stmt_items .
    (34) _3_stmt_items -> _3_stmt_items . _3_stmt_item
    (36) _3_stmt_item -> . stmt
    (37) stmt -> . break_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . if_stmt
    (41) stmt -> . compound_stmt
    (42) stmt -> . expr_stmt
    (51) break_stmt -> . CONTINUE ;
    (52) break_stmt -> . BREAK ;
    (48) return_stmt -> . RETURN _4_expr_optional ;
    (45) while_stmt -> . WHILE ( expr ) stmt
    (46) if_stmt -> . IF ( expr ) stmt
    (47) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (26) compound_stmt -> . { local_decls stmt_list }
    (43) expr_stmt -> . ;
    (44) expr_stmt -> . expr ;
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    }               reduce using rule 32 (_3_stmt_repeat -> _3_stmt_items .)
    CONTINUE        shift and go to state 53
    BREAK           shift and go to state 55
    RETURN          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 60
    {               shift and go to state 34
    ;               shift and go to state 54
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    _3_stmt_item                   shift and go to state 72
    stmt                           shift and go to state 46
    break_stmt                     shift and go to state 47
    return_stmt                    shift and go to state 48
    while_stmt                     shift and go to state 49
    if_stmt                        shift and go to state 50
    compound_stmt                  shift and go to state 51
    expr_stmt                      shift and go to state 52
    expr                           shift and go to state 59

state 45

    (35) _3_stmt_items -> _3_stmt_item .
    CONTINUE        reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    BREAK           reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    RETURN          reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    WHILE           reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    IF              reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    {               reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    ;               reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    NEW             reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    STRING          reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    FLOAT_LIT       reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    INT_LIT         reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    BOOL_LIT        reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    IDENT           reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    (               reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    +               reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    -               reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    !               reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)
    }               reduce using rule 35 (_3_stmt_items -> _3_stmt_item .)


state 46

    (36) _3_stmt_item -> stmt .
    CONTINUE        reduce using rule 36 (_3_stmt_item -> stmt .)
    BREAK           reduce using rule 36 (_3_stmt_item -> stmt .)
    RETURN          reduce using rule 36 (_3_stmt_item -> stmt .)
    WHILE           reduce using rule 36 (_3_stmt_item -> stmt .)
    IF              reduce using rule 36 (_3_stmt_item -> stmt .)
    {               reduce using rule 36 (_3_stmt_item -> stmt .)
    ;               reduce using rule 36 (_3_stmt_item -> stmt .)
    NEW             reduce using rule 36 (_3_stmt_item -> stmt .)
    STRING          reduce using rule 36 (_3_stmt_item -> stmt .)
    FLOAT_LIT       reduce using rule 36 (_3_stmt_item -> stmt .)
    INT_LIT         reduce using rule 36 (_3_stmt_item -> stmt .)
    BOOL_LIT        reduce using rule 36 (_3_stmt_item -> stmt .)
    IDENT           reduce using rule 36 (_3_stmt_item -> stmt .)
    (               reduce using rule 36 (_3_stmt_item -> stmt .)
    +               reduce using rule 36 (_3_stmt_item -> stmt .)
    -               reduce using rule 36 (_3_stmt_item -> stmt .)
    !               reduce using rule 36 (_3_stmt_item -> stmt .)
    }               reduce using rule 36 (_3_stmt_item -> stmt .)


state 47

    (37) stmt -> break_stmt .
    CONTINUE        reduce using rule 37 (stmt -> break_stmt .)
    BREAK           reduce using rule 37 (stmt -> break_stmt .)
    RETURN          reduce using rule 37 (stmt -> break_stmt .)
    WHILE           reduce using rule 37 (stmt -> break_stmt .)
    IF              reduce using rule 37 (stmt -> break_stmt .)
    {               reduce using rule 37 (stmt -> break_stmt .)
    ;               reduce using rule 37 (stmt -> break_stmt .)
    NEW             reduce using rule 37 (stmt -> break_stmt .)
    STRING          reduce using rule 37 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 37 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 37 (stmt -> break_stmt .)
    BOOL_LIT        reduce using rule 37 (stmt -> break_stmt .)
    IDENT           reduce using rule 37 (stmt -> break_stmt .)
    (               reduce using rule 37 (stmt -> break_stmt .)
    +               reduce using rule 37 (stmt -> break_stmt .)
    -               reduce using rule 37 (stmt -> break_stmt .)
    !               reduce using rule 37 (stmt -> break_stmt .)
    }               reduce using rule 37 (stmt -> break_stmt .)
    ELSE            reduce using rule 37 (stmt -> break_stmt .)


state 48

    (38) stmt -> return_stmt .
    CONTINUE        reduce using rule 38 (stmt -> return_stmt .)
    BREAK           reduce using rule 38 (stmt -> return_stmt .)
    RETURN          reduce using rule 38 (stmt -> return_stmt .)
    WHILE           reduce using rule 38 (stmt -> return_stmt .)
    IF              reduce using rule 38 (stmt -> return_stmt .)
    {               reduce using rule 38 (stmt -> return_stmt .)
    ;               reduce using rule 38 (stmt -> return_stmt .)
    NEW             reduce using rule 38 (stmt -> return_stmt .)
    STRING          reduce using rule 38 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 38 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 38 (stmt -> return_stmt .)
    BOOL_LIT        reduce using rule 38 (stmt -> return_stmt .)
    IDENT           reduce using rule 38 (stmt -> return_stmt .)
    (               reduce using rule 38 (stmt -> return_stmt .)
    +               reduce using rule 38 (stmt -> return_stmt .)
    -               reduce using rule 38 (stmt -> return_stmt .)
    !               reduce using rule 38 (stmt -> return_stmt .)
    }               reduce using rule 38 (stmt -> return_stmt .)
    ELSE            reduce using rule 38 (stmt -> return_stmt .)


state 49

    (39) stmt -> while_stmt .
    CONTINUE        reduce using rule 39 (stmt -> while_stmt .)
    BREAK           reduce using rule 39 (stmt -> while_stmt .)
    RETURN          reduce using rule 39 (stmt -> while_stmt .)
    WHILE           reduce using rule 39 (stmt -> while_stmt .)
    IF              reduce using rule 39 (stmt -> while_stmt .)
    {               reduce using rule 39 (stmt -> while_stmt .)
    ;               reduce using rule 39 (stmt -> while_stmt .)
    NEW             reduce using rule 39 (stmt -> while_stmt .)
    STRING          reduce using rule 39 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 39 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 39 (stmt -> while_stmt .)
    BOOL_LIT        reduce using rule 39 (stmt -> while_stmt .)
    IDENT           reduce using rule 39 (stmt -> while_stmt .)
    (               reduce using rule 39 (stmt -> while_stmt .)
    +               reduce using rule 39 (stmt -> while_stmt .)
    -               reduce using rule 39 (stmt -> while_stmt .)
    !               reduce using rule 39 (stmt -> while_stmt .)
    }               reduce using rule 39 (stmt -> while_stmt .)
    ELSE            reduce using rule 39 (stmt -> while_stmt .)


state 50

    (40) stmt -> if_stmt .
    CONTINUE        reduce using rule 40 (stmt -> if_stmt .)
    BREAK           reduce using rule 40 (stmt -> if_stmt .)
    RETURN          reduce using rule 40 (stmt -> if_stmt .)
    WHILE           reduce using rule 40 (stmt -> if_stmt .)
    IF              reduce using rule 40 (stmt -> if_stmt .)
    {               reduce using rule 40 (stmt -> if_stmt .)
    ;               reduce using rule 40 (stmt -> if_stmt .)
    NEW             reduce using rule 40 (stmt -> if_stmt .)
    STRING          reduce using rule 40 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 40 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 40 (stmt -> if_stmt .)
    BOOL_LIT        reduce using rule 40 (stmt -> if_stmt .)
    IDENT           reduce using rule 40 (stmt -> if_stmt .)
    (               reduce using rule 40 (stmt -> if_stmt .)
    +               reduce using rule 40 (stmt -> if_stmt .)
    -               reduce using rule 40 (stmt -> if_stmt .)
    !               reduce using rule 40 (stmt -> if_stmt .)
    }               reduce using rule 40 (stmt -> if_stmt .)
    ELSE            reduce using rule 40 (stmt -> if_stmt .)


state 51

    (41) stmt -> compound_stmt .
    CONTINUE        reduce using rule 41 (stmt -> compound_stmt .)
    BREAK           reduce using rule 41 (stmt -> compound_stmt .)
    RETURN          reduce using rule 41 (stmt -> compound_stmt .)
    WHILE           reduce using rule 41 (stmt -> compound_stmt .)
    IF              reduce using rule 41 (stmt -> compound_stmt .)
    {               reduce using rule 41 (stmt -> compound_stmt .)
    ;               reduce using rule 41 (stmt -> compound_stmt .)
    NEW             reduce using rule 41 (stmt -> compound_stmt .)
    STRING          reduce using rule 41 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 41 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 41 (stmt -> compound_stmt .)
    BOOL_LIT        reduce using rule 41 (stmt -> compound_stmt .)
    IDENT           reduce using rule 41 (stmt -> compound_stmt .)
    (               reduce using rule 41 (stmt -> compound_stmt .)
    +               reduce using rule 41 (stmt -> compound_stmt .)
    -               reduce using rule 41 (stmt -> compound_stmt .)
    !               reduce using rule 41 (stmt -> compound_stmt .)
    }               reduce using rule 41 (stmt -> compound_stmt .)
    ELSE            reduce using rule 41 (stmt -> compound_stmt .)


state 52

    (42) stmt -> expr_stmt .
    CONTINUE        reduce using rule 42 (stmt -> expr_stmt .)
    BREAK           reduce using rule 42 (stmt -> expr_stmt .)
    RETURN          reduce using rule 42 (stmt -> expr_stmt .)
    WHILE           reduce using rule 42 (stmt -> expr_stmt .)
    IF              reduce using rule 42 (stmt -> expr_stmt .)
    {               reduce using rule 42 (stmt -> expr_stmt .)
    ;               reduce using rule 42 (stmt -> expr_stmt .)
    NEW             reduce using rule 42 (stmt -> expr_stmt .)
    STRING          reduce using rule 42 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 42 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 42 (stmt -> expr_stmt .)
    BOOL_LIT        reduce using rule 42 (stmt -> expr_stmt .)
    IDENT           reduce using rule 42 (stmt -> expr_stmt .)
    (               reduce using rule 42 (stmt -> expr_stmt .)
    +               reduce using rule 42 (stmt -> expr_stmt .)
    -               reduce using rule 42 (stmt -> expr_stmt .)
    !               reduce using rule 42 (stmt -> expr_stmt .)
    }               reduce using rule 42 (stmt -> expr_stmt .)
    ELSE            reduce using rule 42 (stmt -> expr_stmt .)


state 53

    (51) break_stmt -> CONTINUE . ;
    ;               shift and go to state 73


state 54

    (43) expr_stmt -> ; .
    CONTINUE        reduce using rule 43 (expr_stmt -> ; .)
    BREAK           reduce using rule 43 (expr_stmt -> ; .)
    RETURN          reduce using rule 43 (expr_stmt -> ; .)
    WHILE           reduce using rule 43 (expr_stmt -> ; .)
    IF              reduce using rule 43 (expr_stmt -> ; .)
    {               reduce using rule 43 (expr_stmt -> ; .)
    ;               reduce using rule 43 (expr_stmt -> ; .)
    NEW             reduce using rule 43 (expr_stmt -> ; .)
    STRING          reduce using rule 43 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 43 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 43 (expr_stmt -> ; .)
    BOOL_LIT        reduce using rule 43 (expr_stmt -> ; .)
    IDENT           reduce using rule 43 (expr_stmt -> ; .)
    (               reduce using rule 43 (expr_stmt -> ; .)
    +               reduce using rule 43 (expr_stmt -> ; .)
    -               reduce using rule 43 (expr_stmt -> ; .)
    !               reduce using rule 43 (expr_stmt -> ; .)
    }               reduce using rule 43 (expr_stmt -> ; .)
    ELSE            reduce using rule 43 (expr_stmt -> ; .)


state 55

    (52) break_stmt -> BREAK . ;
    ;               shift and go to state 74


state 56

    (48) return_stmt -> RETURN . _4_expr_optional ;
    (49) _4_expr_optional -> . expr
    (50) _4_expr_optional -> .
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    ;               reduce using rule 50 (_4_expr_optional -> .)
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    _4_expr_optional               shift and go to state 75
    expr                           shift and go to state 76

state 57

    (45) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 77


state 58

    (62) expr -> ( . expr )
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 78

state 59

    (44) expr_stmt -> expr . ;
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               shift and go to state 79
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90
    AND             shift and go to state 91
    OR              shift and go to state 92


state 60

    (46) if_stmt -> IF . ( expr ) stmt
    (47) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (               shift and go to state 93


state 61

    (53) expr -> NEW . type_spec [ expr ]
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    type_spec                      shift and go to state 94

state 62

    (54) expr -> STRING .
    ;               reduce using rule 54 (expr -> STRING .)
    %               reduce using rule 54 (expr -> STRING .)
    /               reduce using rule 54 (expr -> STRING .)
    *               reduce using rule 54 (expr -> STRING .)
    -               reduce using rule 54 (expr -> STRING .)
    +               reduce using rule 54 (expr -> STRING .)
    >               reduce using rule 54 (expr -> STRING .)
    GE              reduce using rule 54 (expr -> STRING .)
    <               reduce using rule 54 (expr -> STRING .)
    LE              reduce using rule 54 (expr -> STRING .)
    NE              reduce using rule 54 (expr -> STRING .)
    EQ              reduce using rule 54 (expr -> STRING .)
    AND             reduce using rule 54 (expr -> STRING .)
    OR              reduce using rule 54 (expr -> STRING .)
    )               reduce using rule 54 (expr -> STRING .)
    ,               reduce using rule 54 (expr -> STRING .)
    ]               reduce using rule 54 (expr -> STRING .)


state 63

    (55) expr -> FLOAT_LIT .
    ;               reduce using rule 55 (expr -> FLOAT_LIT .)
    %               reduce using rule 55 (expr -> FLOAT_LIT .)
    /               reduce using rule 55 (expr -> FLOAT_LIT .)
    *               reduce using rule 55 (expr -> FLOAT_LIT .)
    -               reduce using rule 55 (expr -> FLOAT_LIT .)
    +               reduce using rule 55 (expr -> FLOAT_LIT .)
    >               reduce using rule 55 (expr -> FLOAT_LIT .)
    GE              reduce using rule 55 (expr -> FLOAT_LIT .)
    <               reduce using rule 55 (expr -> FLOAT_LIT .)
    LE              reduce using rule 55 (expr -> FLOAT_LIT .)
    NE              reduce using rule 55 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 55 (expr -> FLOAT_LIT .)
    AND             reduce using rule 55 (expr -> FLOAT_LIT .)
    OR              reduce using rule 55 (expr -> FLOAT_LIT .)
    )               reduce using rule 55 (expr -> FLOAT_LIT .)
    ,               reduce using rule 55 (expr -> FLOAT_LIT .)
    ]               reduce using rule 55 (expr -> FLOAT_LIT .)


state 64

    (56) expr -> INT_LIT .
    ;               reduce using rule 56 (expr -> INT_LIT .)
    %               reduce using rule 56 (expr -> INT_LIT .)
    /               reduce using rule 56 (expr -> INT_LIT .)
    *               reduce using rule 56 (expr -> INT_LIT .)
    -               reduce using rule 56 (expr -> INT_LIT .)
    +               reduce using rule 56 (expr -> INT_LIT .)
    >               reduce using rule 56 (expr -> INT_LIT .)
    GE              reduce using rule 56 (expr -> INT_LIT .)
    <               reduce using rule 56 (expr -> INT_LIT .)
    LE              reduce using rule 56 (expr -> INT_LIT .)
    NE              reduce using rule 56 (expr -> INT_LIT .)
    EQ              reduce using rule 56 (expr -> INT_LIT .)
    AND             reduce using rule 56 (expr -> INT_LIT .)
    OR              reduce using rule 56 (expr -> INT_LIT .)
    )               reduce using rule 56 (expr -> INT_LIT .)
    ,               reduce using rule 56 (expr -> INT_LIT .)
    ]               reduce using rule 56 (expr -> INT_LIT .)


state 65

    (57) expr -> BOOL_LIT .
    ;               reduce using rule 57 (expr -> BOOL_LIT .)
    %               reduce using rule 57 (expr -> BOOL_LIT .)
    /               reduce using rule 57 (expr -> BOOL_LIT .)
    *               reduce using rule 57 (expr -> BOOL_LIT .)
    -               reduce using rule 57 (expr -> BOOL_LIT .)
    +               reduce using rule 57 (expr -> BOOL_LIT .)
    >               reduce using rule 57 (expr -> BOOL_LIT .)
    GE              reduce using rule 57 (expr -> BOOL_LIT .)
    <               reduce using rule 57 (expr -> BOOL_LIT .)
    LE              reduce using rule 57 (expr -> BOOL_LIT .)
    NE              reduce using rule 57 (expr -> BOOL_LIT .)
    EQ              reduce using rule 57 (expr -> BOOL_LIT .)
    AND             reduce using rule 57 (expr -> BOOL_LIT .)
    OR              reduce using rule 57 (expr -> BOOL_LIT .)
    )               reduce using rule 57 (expr -> BOOL_LIT .)
    ,               reduce using rule 57 (expr -> BOOL_LIT .)
    ]               reduce using rule 57 (expr -> BOOL_LIT .)


state 66

    (58) expr -> IDENT . . SIZE
    (59) expr -> IDENT . ( args )
    (60) expr -> IDENT . [ expr ]
    (61) expr -> IDENT .
    (79) expr -> IDENT . [ expr ] = expr
    (80) expr -> IDENT . = expr
    .               shift and go to state 95
    (               shift and go to state 96
    [               shift and go to state 97
    ;               reduce using rule 61 (expr -> IDENT .)
    %               reduce using rule 61 (expr -> IDENT .)
    /               reduce using rule 61 (expr -> IDENT .)
    *               reduce using rule 61 (expr -> IDENT .)
    -               reduce using rule 61 (expr -> IDENT .)
    +               reduce using rule 61 (expr -> IDENT .)
    >               reduce using rule 61 (expr -> IDENT .)
    GE              reduce using rule 61 (expr -> IDENT .)
    <               reduce using rule 61 (expr -> IDENT .)
    LE              reduce using rule 61 (expr -> IDENT .)
    NE              reduce using rule 61 (expr -> IDENT .)
    EQ              reduce using rule 61 (expr -> IDENT .)
    AND             reduce using rule 61 (expr -> IDENT .)
    OR              reduce using rule 61 (expr -> IDENT .)
    )               reduce using rule 61 (expr -> IDENT .)
    ,               reduce using rule 61 (expr -> IDENT .)
    ]               reduce using rule 61 (expr -> IDENT .)
    =               shift and go to state 98


state 67

    (63) expr -> + . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 99

state 68

    (64) expr -> - . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 100

state 69

    (65) expr -> ! . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 101

state 70

    (29) local_decl -> type_spec IDENT . [ ] ;
    (30) local_decl -> type_spec IDENT . ;
    [               shift and go to state 102
    ;               shift and go to state 103


state 71

    (26) compound_stmt -> { local_decls stmt_list } .
    FLOAT           reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    CONTINUE        reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    NEW             reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    STRING          reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    BOOL_LIT        reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 26 (compound_stmt -> { local_decls stmt_list } .)


state 72

    (34) _3_stmt_items -> _3_stmt_items _3_stmt_item .
    CONTINUE        reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    BREAK           reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    RETURN          reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    WHILE           reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    IF              reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    {               reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    ;               reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    NEW             reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    STRING          reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    FLOAT_LIT       reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    INT_LIT         reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    BOOL_LIT        reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    IDENT           reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    (               reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    +               reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    -               reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    !               reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)
    }               reduce using rule 34 (_3_stmt_items -> _3_stmt_items _3_stmt_item .)


state 73

    (51) break_stmt -> CONTINUE ; .
    CONTINUE        reduce using rule 51 (break_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 51 (break_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 51 (break_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 51 (break_stmt -> CONTINUE ; .)
    IF              reduce using rule 51 (break_stmt -> CONTINUE ; .)
    {               reduce using rule 51 (break_stmt -> CONTINUE ; .)
    ;               reduce using rule 51 (break_stmt -> CONTINUE ; .)
    NEW             reduce using rule 51 (break_stmt -> CONTINUE ; .)
    STRING          reduce using rule 51 (break_stmt -> CONTINUE ; .)
    FLOAT_LIT       reduce using rule 51 (break_stmt -> CONTINUE ; .)
    INT_LIT         reduce using rule 51 (break_stmt -> CONTINUE ; .)
    BOOL_LIT        reduce using rule 51 (break_stmt -> CONTINUE ; .)
    IDENT           reduce using rule 51 (break_stmt -> CONTINUE ; .)
    (               reduce using rule 51 (break_stmt -> CONTINUE ; .)
    +               reduce using rule 51 (break_stmt -> CONTINUE ; .)
    -               reduce using rule 51 (break_stmt -> CONTINUE ; .)
    !               reduce using rule 51 (break_stmt -> CONTINUE ; .)
    }               reduce using rule 51 (break_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 51 (break_stmt -> CONTINUE ; .)


state 74

    (52) break_stmt -> BREAK ; .
    CONTINUE        reduce using rule 52 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 52 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 52 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 52 (break_stmt -> BREAK ; .)
    IF              reduce using rule 52 (break_stmt -> BREAK ; .)
    {               reduce using rule 52 (break_stmt -> BREAK ; .)
    ;               reduce using rule 52 (break_stmt -> BREAK ; .)
    NEW             reduce using rule 52 (break_stmt -> BREAK ; .)
    STRING          reduce using rule 52 (break_stmt -> BREAK ; .)
    FLOAT_LIT       reduce using rule 52 (break_stmt -> BREAK ; .)
    INT_LIT         reduce using rule 52 (break_stmt -> BREAK ; .)
    BOOL_LIT        reduce using rule 52 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 52 (break_stmt -> BREAK ; .)
    (               reduce using rule 52 (break_stmt -> BREAK ; .)
    +               reduce using rule 52 (break_stmt -> BREAK ; .)
    -               reduce using rule 52 (break_stmt -> BREAK ; .)
    !               reduce using rule 52 (break_stmt -> BREAK ; .)
    }               reduce using rule 52 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 52 (break_stmt -> BREAK ; .)


state 75

    (48) return_stmt -> RETURN _4_expr_optional . ;
    ;               shift and go to state 104


state 76

    (49) _4_expr_optional -> expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 49 (_4_expr_optional -> expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90
    AND             shift and go to state 91
    OR              shift and go to state 92


state 77

    (45) while_stmt -> WHILE ( . expr ) stmt
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 105

state 78

    (62) expr -> ( expr . )
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    )               shift and go to state 106
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90
    AND             shift and go to state 91
    OR              shift and go to state 92


state 79

    (44) expr_stmt -> expr ; .
    CONTINUE        reduce using rule 44 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 44 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 44 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 44 (expr_stmt -> expr ; .)
    IF              reduce using rule 44 (expr_stmt -> expr ; .)
    {               reduce using rule 44 (expr_stmt -> expr ; .)
    ;               reduce using rule 44 (expr_stmt -> expr ; .)
    NEW             reduce using rule 44 (expr_stmt -> expr ; .)
    STRING          reduce using rule 44 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 44 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 44 (expr_stmt -> expr ; .)
    BOOL_LIT        reduce using rule 44 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 44 (expr_stmt -> expr ; .)
    (               reduce using rule 44 (expr_stmt -> expr ; .)
    +               reduce using rule 44 (expr_stmt -> expr ; .)
    -               reduce using rule 44 (expr_stmt -> expr ; .)
    !               reduce using rule 44 (expr_stmt -> expr ; .)
    }               reduce using rule 44 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 44 (expr_stmt -> expr ; .)


state 80

    (66) expr -> expr % . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 107

state 81

    (67) expr -> expr / . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 108

state 82

    (68) expr -> expr * . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 109

state 83

    (69) expr -> expr - . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 110

state 84

    (70) expr -> expr + . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 111

state 85

    (71) expr -> expr > . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 112

state 86

    (72) expr -> expr GE . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 113

state 87

    (73) expr -> expr < . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 114

state 88

    (74) expr -> expr LE . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 115

state 89

    (75) expr -> expr NE . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 116

state 90

    (76) expr -> expr EQ . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 117

state 91

    (77) expr -> expr AND . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 118

state 92

    (78) expr -> expr OR . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 119

state 93

    (46) if_stmt -> IF ( . expr ) stmt
    (47) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 120

state 94

    (53) expr -> NEW type_spec . [ expr ]
    [               shift and go to state 121


state 95

    (58) expr -> IDENT . . SIZE
    SIZE            shift and go to state 122


state 96

    (59) expr -> IDENT ( . args )
    (81) args -> . empty
    (82) args -> . arg_list
    (86) empty -> .
    (83) arg_list -> . expr _5_0x2c_expr_optional
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    )               reduce using rule 86 (empty -> .)
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    args                           shift and go to state 123
    empty                          shift and go to state 124
    arg_list                       shift and go to state 125
    expr                           shift and go to state 126

state 97

    (60) expr -> IDENT [ . expr ]
    (79) expr -> IDENT [ . expr ] = expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 127

state 98

    (80) expr -> IDENT = . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 128

state 99

    (63) expr -> + expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 63 (expr -> + expr .)
    %               reduce using rule 63 (expr -> + expr .)
    /               reduce using rule 63 (expr -> + expr .)
    *               reduce using rule 63 (expr -> + expr .)
    -               reduce using rule 63 (expr -> + expr .)
    +               reduce using rule 63 (expr -> + expr .)
    >               reduce using rule 63 (expr -> + expr .)
    GE              reduce using rule 63 (expr -> + expr .)
    <               reduce using rule 63 (expr -> + expr .)
    LE              reduce using rule 63 (expr -> + expr .)
    NE              reduce using rule 63 (expr -> + expr .)
    EQ              reduce using rule 63 (expr -> + expr .)
    AND             reduce using rule 63 (expr -> + expr .)
    OR              reduce using rule 63 (expr -> + expr .)
    )               reduce using rule 63 (expr -> + expr .)
    ,               reduce using rule 63 (expr -> + expr .)
    ]               reduce using rule 63 (expr -> + expr .)


state 100

    (64) expr -> - expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 64 (expr -> - expr .)
    %               reduce using rule 64 (expr -> - expr .)
    /               reduce using rule 64 (expr -> - expr .)
    *               reduce using rule 64 (expr -> - expr .)
    -               reduce using rule 64 (expr -> - expr .)
    +               reduce using rule 64 (expr -> - expr .)
    >               reduce using rule 64 (expr -> - expr .)
    GE              reduce using rule 64 (expr -> - expr .)
    <               reduce using rule 64 (expr -> - expr .)
    LE              reduce using rule 64 (expr -> - expr .)
    NE              reduce using rule 64 (expr -> - expr .)
    EQ              reduce using rule 64 (expr -> - expr .)
    AND             reduce using rule 64 (expr -> - expr .)
    OR              reduce using rule 64 (expr -> - expr .)
    )               reduce using rule 64 (expr -> - expr .)
    ,               reduce using rule 64 (expr -> - expr .)
    ]               reduce using rule 64 (expr -> - expr .)


state 101

    (65) expr -> ! expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 65 (expr -> ! expr .)
    %               reduce using rule 65 (expr -> ! expr .)
    /               reduce using rule 65 (expr -> ! expr .)
    *               reduce using rule 65 (expr -> ! expr .)
    -               reduce using rule 65 (expr -> ! expr .)
    +               reduce using rule 65 (expr -> ! expr .)
    >               reduce using rule 65 (expr -> ! expr .)
    GE              reduce using rule 65 (expr -> ! expr .)
    <               reduce using rule 65 (expr -> ! expr .)
    LE              reduce using rule 65 (expr -> ! expr .)
    NE              reduce using rule 65 (expr -> ! expr .)
    EQ              reduce using rule 65 (expr -> ! expr .)
    AND             reduce using rule 65 (expr -> ! expr .)
    OR              reduce using rule 65 (expr -> ! expr .)
    )               reduce using rule 65 (expr -> ! expr .)
    ,               reduce using rule 65 (expr -> ! expr .)
    ]               reduce using rule 65 (expr -> ! expr .)


state 102

    (29) local_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 129


state 103

    (30) local_decl -> type_spec IDENT ; .
    CONTINUE        reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    IF              reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    {               reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    ;               reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    NEW             reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    STRING          reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    BOOL_LIT        reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    (               reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    +               reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    -               reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    !               reduce using rule 30 (local_decl -> type_spec IDENT ; .)
    }               reduce using rule 30 (local_decl -> type_spec IDENT ; .)


state 104

    (48) return_stmt -> RETURN _4_expr_optional ; .
    CONTINUE        reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    BREAK           reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    RETURN          reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    WHILE           reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    IF              reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    {               reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    ;               reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    NEW             reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    STRING          reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    FLOAT_LIT       reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    INT_LIT         reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    BOOL_LIT        reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    IDENT           reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    (               reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    +               reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    -               reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    !               reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    }               reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)
    ELSE            reduce using rule 48 (return_stmt -> RETURN _4_expr_optional ; .)


state 105

    (45) while_stmt -> WHILE ( expr . ) stmt
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    )               shift and go to state 130
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90
    AND             shift and go to state 91
    OR              shift and go to state 92


state 106

    (62) expr -> ( expr ) .
    ;               reduce using rule 62 (expr -> ( expr ) .)
    %               reduce using rule 62 (expr -> ( expr ) .)
    /               reduce using rule 62 (expr -> ( expr ) .)
    *               reduce using rule 62 (expr -> ( expr ) .)
    -               reduce using rule 62 (expr -> ( expr ) .)
    +               reduce using rule 62 (expr -> ( expr ) .)
    >               reduce using rule 62 (expr -> ( expr ) .)
    GE              reduce using rule 62 (expr -> ( expr ) .)
    <               reduce using rule 62 (expr -> ( expr ) .)
    LE              reduce using rule 62 (expr -> ( expr ) .)
    NE              reduce using rule 62 (expr -> ( expr ) .)
    EQ              reduce using rule 62 (expr -> ( expr ) .)
    AND             reduce using rule 62 (expr -> ( expr ) .)
    OR              reduce using rule 62 (expr -> ( expr ) .)
    )               reduce using rule 62 (expr -> ( expr ) .)
    ,               reduce using rule 62 (expr -> ( expr ) .)
    ]               reduce using rule 62 (expr -> ( expr ) .)


state 107

    (66) expr -> expr % expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 66 (expr -> expr % expr .)
    %               reduce using rule 66 (expr -> expr % expr .)
    /               reduce using rule 66 (expr -> expr % expr .)
    *               reduce using rule 66 (expr -> expr % expr .)
    -               reduce using rule 66 (expr -> expr % expr .)
    +               reduce using rule 66 (expr -> expr % expr .)
    >               reduce using rule 66 (expr -> expr % expr .)
    GE              reduce using rule 66 (expr -> expr % expr .)
    <               reduce using rule 66 (expr -> expr % expr .)
    LE              reduce using rule 66 (expr -> expr % expr .)
    NE              reduce using rule 66 (expr -> expr % expr .)
    EQ              reduce using rule 66 (expr -> expr % expr .)
    AND             reduce using rule 66 (expr -> expr % expr .)
    OR              reduce using rule 66 (expr -> expr % expr .)
    )               reduce using rule 66 (expr -> expr % expr .)
    ,               reduce using rule 66 (expr -> expr % expr .)
    ]               reduce using rule 66 (expr -> expr % expr .)


state 108

    (67) expr -> expr / expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 67 (expr -> expr / expr .)
    %               reduce using rule 67 (expr -> expr / expr .)
    /               reduce using rule 67 (expr -> expr / expr .)
    *               reduce using rule 67 (expr -> expr / expr .)
    -               reduce using rule 67 (expr -> expr / expr .)
    +               reduce using rule 67 (expr -> expr / expr .)
    >               reduce using rule 67 (expr -> expr / expr .)
    GE              reduce using rule 67 (expr -> expr / expr .)
    <               reduce using rule 67 (expr -> expr / expr .)
    LE              reduce using rule 67 (expr -> expr / expr .)
    NE              reduce using rule 67 (expr -> expr / expr .)
    EQ              reduce using rule 67 (expr -> expr / expr .)
    AND             reduce using rule 67 (expr -> expr / expr .)
    OR              reduce using rule 67 (expr -> expr / expr .)
    )               reduce using rule 67 (expr -> expr / expr .)
    ,               reduce using rule 67 (expr -> expr / expr .)
    ]               reduce using rule 67 (expr -> expr / expr .)


state 109

    (68) expr -> expr * expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 68 (expr -> expr * expr .)
    %               reduce using rule 68 (expr -> expr * expr .)
    /               reduce using rule 68 (expr -> expr * expr .)
    *               reduce using rule 68 (expr -> expr * expr .)
    -               reduce using rule 68 (expr -> expr * expr .)
    +               reduce using rule 68 (expr -> expr * expr .)
    >               reduce using rule 68 (expr -> expr * expr .)
    GE              reduce using rule 68 (expr -> expr * expr .)
    <               reduce using rule 68 (expr -> expr * expr .)
    LE              reduce using rule 68 (expr -> expr * expr .)
    NE              reduce using rule 68 (expr -> expr * expr .)
    EQ              reduce using rule 68 (expr -> expr * expr .)
    AND             reduce using rule 68 (expr -> expr * expr .)
    OR              reduce using rule 68 (expr -> expr * expr .)
    )               reduce using rule 68 (expr -> expr * expr .)
    ,               reduce using rule 68 (expr -> expr * expr .)
    ]               reduce using rule 68 (expr -> expr * expr .)


state 110

    (69) expr -> expr - expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 69 (expr -> expr - expr .)
    -               reduce using rule 69 (expr -> expr - expr .)
    +               reduce using rule 69 (expr -> expr - expr .)
    >               reduce using rule 69 (expr -> expr - expr .)
    GE              reduce using rule 69 (expr -> expr - expr .)
    <               reduce using rule 69 (expr -> expr - expr .)
    LE              reduce using rule 69 (expr -> expr - expr .)
    NE              reduce using rule 69 (expr -> expr - expr .)
    EQ              reduce using rule 69 (expr -> expr - expr .)
    AND             reduce using rule 69 (expr -> expr - expr .)
    OR              reduce using rule 69 (expr -> expr - expr .)
    )               reduce using rule 69 (expr -> expr - expr .)
    ,               reduce using rule 69 (expr -> expr - expr .)
    ]               reduce using rule 69 (expr -> expr - expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82


state 111

    (70) expr -> expr + expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 70 (expr -> expr + expr .)
    -               reduce using rule 70 (expr -> expr + expr .)
    +               reduce using rule 70 (expr -> expr + expr .)
    >               reduce using rule 70 (expr -> expr + expr .)
    GE              reduce using rule 70 (expr -> expr + expr .)
    <               reduce using rule 70 (expr -> expr + expr .)
    LE              reduce using rule 70 (expr -> expr + expr .)
    NE              reduce using rule 70 (expr -> expr + expr .)
    EQ              reduce using rule 70 (expr -> expr + expr .)
    AND             reduce using rule 70 (expr -> expr + expr .)
    OR              reduce using rule 70 (expr -> expr + expr .)
    )               reduce using rule 70 (expr -> expr + expr .)
    ,               reduce using rule 70 (expr -> expr + expr .)
    ]               reduce using rule 70 (expr -> expr + expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82


state 112

    (71) expr -> expr > expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 71 (expr -> expr > expr .)
    >               reduce using rule 71 (expr -> expr > expr .)
    GE              reduce using rule 71 (expr -> expr > expr .)
    <               reduce using rule 71 (expr -> expr > expr .)
    LE              reduce using rule 71 (expr -> expr > expr .)
    NE              reduce using rule 71 (expr -> expr > expr .)
    EQ              reduce using rule 71 (expr -> expr > expr .)
    AND             reduce using rule 71 (expr -> expr > expr .)
    OR              reduce using rule 71 (expr -> expr > expr .)
    )               reduce using rule 71 (expr -> expr > expr .)
    ,               reduce using rule 71 (expr -> expr > expr .)
    ]               reduce using rule 71 (expr -> expr > expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84


state 113

    (72) expr -> expr GE expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 72 (expr -> expr GE expr .)
    >               reduce using rule 72 (expr -> expr GE expr .)
    GE              reduce using rule 72 (expr -> expr GE expr .)
    <               reduce using rule 72 (expr -> expr GE expr .)
    LE              reduce using rule 72 (expr -> expr GE expr .)
    NE              reduce using rule 72 (expr -> expr GE expr .)
    EQ              reduce using rule 72 (expr -> expr GE expr .)
    AND             reduce using rule 72 (expr -> expr GE expr .)
    OR              reduce using rule 72 (expr -> expr GE expr .)
    )               reduce using rule 72 (expr -> expr GE expr .)
    ,               reduce using rule 72 (expr -> expr GE expr .)
    ]               reduce using rule 72 (expr -> expr GE expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84


state 114

    (73) expr -> expr < expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 73 (expr -> expr < expr .)
    >               reduce using rule 73 (expr -> expr < expr .)
    GE              reduce using rule 73 (expr -> expr < expr .)
    <               reduce using rule 73 (expr -> expr < expr .)
    LE              reduce using rule 73 (expr -> expr < expr .)
    NE              reduce using rule 73 (expr -> expr < expr .)
    EQ              reduce using rule 73 (expr -> expr < expr .)
    AND             reduce using rule 73 (expr -> expr < expr .)
    OR              reduce using rule 73 (expr -> expr < expr .)
    )               reduce using rule 73 (expr -> expr < expr .)
    ,               reduce using rule 73 (expr -> expr < expr .)
    ]               reduce using rule 73 (expr -> expr < expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84


state 115

    (74) expr -> expr LE expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 74 (expr -> expr LE expr .)
    >               reduce using rule 74 (expr -> expr LE expr .)
    GE              reduce using rule 74 (expr -> expr LE expr .)
    <               reduce using rule 74 (expr -> expr LE expr .)
    LE              reduce using rule 74 (expr -> expr LE expr .)
    NE              reduce using rule 74 (expr -> expr LE expr .)
    EQ              reduce using rule 74 (expr -> expr LE expr .)
    AND             reduce using rule 74 (expr -> expr LE expr .)
    OR              reduce using rule 74 (expr -> expr LE expr .)
    )               reduce using rule 74 (expr -> expr LE expr .)
    ,               reduce using rule 74 (expr -> expr LE expr .)
    ]               reduce using rule 74 (expr -> expr LE expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84


state 116

    (75) expr -> expr NE expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 75 (expr -> expr NE expr .)
    NE              reduce using rule 75 (expr -> expr NE expr .)
    EQ              reduce using rule 75 (expr -> expr NE expr .)
    AND             reduce using rule 75 (expr -> expr NE expr .)
    OR              reduce using rule 75 (expr -> expr NE expr .)
    )               reduce using rule 75 (expr -> expr NE expr .)
    ,               reduce using rule 75 (expr -> expr NE expr .)
    ]               reduce using rule 75 (expr -> expr NE expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88


state 117

    (76) expr -> expr EQ expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 76 (expr -> expr EQ expr .)
    NE              reduce using rule 76 (expr -> expr EQ expr .)
    EQ              reduce using rule 76 (expr -> expr EQ expr .)
    AND             reduce using rule 76 (expr -> expr EQ expr .)
    OR              reduce using rule 76 (expr -> expr EQ expr .)
    )               reduce using rule 76 (expr -> expr EQ expr .)
    ,               reduce using rule 76 (expr -> expr EQ expr .)
    ]               reduce using rule 76 (expr -> expr EQ expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88


state 118

    (77) expr -> expr AND expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 77 (expr -> expr AND expr .)
    AND             reduce using rule 77 (expr -> expr AND expr .)
    OR              reduce using rule 77 (expr -> expr AND expr .)
    )               reduce using rule 77 (expr -> expr AND expr .)
    ,               reduce using rule 77 (expr -> expr AND expr .)
    ]               reduce using rule 77 (expr -> expr AND expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90


state 119

    (78) expr -> expr OR expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 78 (expr -> expr OR expr .)
    OR              reduce using rule 78 (expr -> expr OR expr .)
    )               reduce using rule 78 (expr -> expr OR expr .)
    ,               reduce using rule 78 (expr -> expr OR expr .)
    ]               reduce using rule 78 (expr -> expr OR expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90
    AND             shift and go to state 91


state 120

    (46) if_stmt -> IF ( expr . ) stmt
    (47) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    )               shift and go to state 131
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90
    AND             shift and go to state 91
    OR              shift and go to state 92


state 121

    (53) expr -> NEW type_spec [ . expr ]
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 132

state 122

    (58) expr -> IDENT . SIZE .
    ;               reduce using rule 58 (expr -> IDENT . SIZE .)
    %               reduce using rule 58 (expr -> IDENT . SIZE .)
    /               reduce using rule 58 (expr -> IDENT . SIZE .)
    *               reduce using rule 58 (expr -> IDENT . SIZE .)
    -               reduce using rule 58 (expr -> IDENT . SIZE .)
    +               reduce using rule 58 (expr -> IDENT . SIZE .)
    >               reduce using rule 58 (expr -> IDENT . SIZE .)
    GE              reduce using rule 58 (expr -> IDENT . SIZE .)
    <               reduce using rule 58 (expr -> IDENT . SIZE .)
    LE              reduce using rule 58 (expr -> IDENT . SIZE .)
    NE              reduce using rule 58 (expr -> IDENT . SIZE .)
    EQ              reduce using rule 58 (expr -> IDENT . SIZE .)
    AND             reduce using rule 58 (expr -> IDENT . SIZE .)
    OR              reduce using rule 58 (expr -> IDENT . SIZE .)
    )               reduce using rule 58 (expr -> IDENT . SIZE .)
    ,               reduce using rule 58 (expr -> IDENT . SIZE .)
    ]               reduce using rule 58 (expr -> IDENT . SIZE .)


state 123

    (59) expr -> IDENT ( args . )
    )               shift and go to state 133


state 124

    (81) args -> empty .
    )               reduce using rule 81 (args -> empty .)


state 125

    (82) args -> arg_list .
    )               reduce using rule 82 (args -> arg_list .)


state 126

    (83) arg_list -> expr . _5_0x2c_expr_optional
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (84) _5_0x2c_expr_optional -> . , expr
    (85) _5_0x2c_expr_optional -> .
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90
    AND             shift and go to state 91
    OR              shift and go to state 92
    ,               shift and go to state 135
    )               reduce using rule 85 (_5_0x2c_expr_optional -> .)

    _5_0x2c_expr_optional          shift and go to state 134

state 127

    (60) expr -> IDENT [ expr . ]
    (79) expr -> IDENT [ expr . ] = expr
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ]               shift and go to state 136
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90
    AND             shift and go to state 91
    OR              shift and go to state 92


state 128

    (80) expr -> IDENT = expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 80 (expr -> IDENT = expr .)
    )               reduce using rule 80 (expr -> IDENT = expr .)
    ,               reduce using rule 80 (expr -> IDENT = expr .)
    ]               reduce using rule 80 (expr -> IDENT = expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90
    AND             shift and go to state 91
    OR              shift and go to state 92


state 129

    (29) local_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 137


state 130

    (45) while_stmt -> WHILE ( expr ) . stmt
    (37) stmt -> . break_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . if_stmt
    (41) stmt -> . compound_stmt
    (42) stmt -> . expr_stmt
    (51) break_stmt -> . CONTINUE ;
    (52) break_stmt -> . BREAK ;
    (48) return_stmt -> . RETURN _4_expr_optional ;
    (45) while_stmt -> . WHILE ( expr ) stmt
    (46) if_stmt -> . IF ( expr ) stmt
    (47) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (26) compound_stmt -> . { local_decls stmt_list }
    (43) expr_stmt -> . ;
    (44) expr_stmt -> . expr ;
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    CONTINUE        shift and go to state 53
    BREAK           shift and go to state 55
    RETURN          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 60
    {               shift and go to state 34
    ;               shift and go to state 54
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 59
    stmt                           shift and go to state 138
    break_stmt                     shift and go to state 47
    return_stmt                    shift and go to state 48
    while_stmt                     shift and go to state 49
    if_stmt                        shift and go to state 50
    compound_stmt                  shift and go to state 51
    expr_stmt                      shift and go to state 52

state 131

    (46) if_stmt -> IF ( expr ) . stmt
    (47) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (37) stmt -> . break_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . if_stmt
    (41) stmt -> . compound_stmt
    (42) stmt -> . expr_stmt
    (51) break_stmt -> . CONTINUE ;
    (52) break_stmt -> . BREAK ;
    (48) return_stmt -> . RETURN _4_expr_optional ;
    (45) while_stmt -> . WHILE ( expr ) stmt
    (46) if_stmt -> . IF ( expr ) stmt
    (47) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (26) compound_stmt -> . { local_decls stmt_list }
    (43) expr_stmt -> . ;
    (44) expr_stmt -> . expr ;
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    CONTINUE        shift and go to state 53
    BREAK           shift and go to state 55
    RETURN          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 60
    {               shift and go to state 34
    ;               shift and go to state 54
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 59
    stmt                           shift and go to state 139
    break_stmt                     shift and go to state 47
    return_stmt                    shift and go to state 48
    while_stmt                     shift and go to state 49
    if_stmt                        shift and go to state 50
    compound_stmt                  shift and go to state 51
    expr_stmt                      shift and go to state 52

state 132

    (53) expr -> NEW type_spec [ expr . ]
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ]               shift and go to state 140
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90
    AND             shift and go to state 91
    OR              shift and go to state 92


state 133

    (59) expr -> IDENT ( args ) .
    ;               reduce using rule 59 (expr -> IDENT ( args ) .)
    %               reduce using rule 59 (expr -> IDENT ( args ) .)
    /               reduce using rule 59 (expr -> IDENT ( args ) .)
    *               reduce using rule 59 (expr -> IDENT ( args ) .)
    -               reduce using rule 59 (expr -> IDENT ( args ) .)
    +               reduce using rule 59 (expr -> IDENT ( args ) .)
    >               reduce using rule 59 (expr -> IDENT ( args ) .)
    GE              reduce using rule 59 (expr -> IDENT ( args ) .)
    <               reduce using rule 59 (expr -> IDENT ( args ) .)
    LE              reduce using rule 59 (expr -> IDENT ( args ) .)
    NE              reduce using rule 59 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 59 (expr -> IDENT ( args ) .)
    AND             reduce using rule 59 (expr -> IDENT ( args ) .)
    OR              reduce using rule 59 (expr -> IDENT ( args ) .)
    )               reduce using rule 59 (expr -> IDENT ( args ) .)
    ,               reduce using rule 59 (expr -> IDENT ( args ) .)
    ]               reduce using rule 59 (expr -> IDENT ( args ) .)


state 134

    (83) arg_list -> expr _5_0x2c_expr_optional .
    )               reduce using rule 83 (arg_list -> expr _5_0x2c_expr_optional .)


state 135

    (84) _5_0x2c_expr_optional -> , . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 141

state 136

    (60) expr -> IDENT [ expr ] .
    (79) expr -> IDENT [ expr ] . = expr
    ;               reduce using rule 60 (expr -> IDENT [ expr ] .)
    %               reduce using rule 60 (expr -> IDENT [ expr ] .)
    /               reduce using rule 60 (expr -> IDENT [ expr ] .)
    *               reduce using rule 60 (expr -> IDENT [ expr ] .)
    -               reduce using rule 60 (expr -> IDENT [ expr ] .)
    +               reduce using rule 60 (expr -> IDENT [ expr ] .)
    >               reduce using rule 60 (expr -> IDENT [ expr ] .)
    GE              reduce using rule 60 (expr -> IDENT [ expr ] .)
    <               reduce using rule 60 (expr -> IDENT [ expr ] .)
    LE              reduce using rule 60 (expr -> IDENT [ expr ] .)
    NE              reduce using rule 60 (expr -> IDENT [ expr ] .)
    EQ              reduce using rule 60 (expr -> IDENT [ expr ] .)
    AND             reduce using rule 60 (expr -> IDENT [ expr ] .)
    OR              reduce using rule 60 (expr -> IDENT [ expr ] .)
    )               reduce using rule 60 (expr -> IDENT [ expr ] .)
    ,               reduce using rule 60 (expr -> IDENT [ expr ] .)
    ]               reduce using rule 60 (expr -> IDENT [ expr ] .)
    =               shift and go to state 142


state 137

    (29) local_decl -> type_spec IDENT [ ] ; .
    CONTINUE        reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    BREAK           reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    RETURN          reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    WHILE           reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    IF              reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    {               reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    ;               reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    NEW             reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    STRING          reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    FLOAT_LIT       reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    INT_LIT         reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL_LIT        reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    IDENT           reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    (               reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    +               reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    -               reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    !               reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)
    }               reduce using rule 29 (local_decl -> type_spec IDENT [ ] ; .)


state 138

    (45) while_stmt -> WHILE ( expr ) stmt .
    CONTINUE        reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    STRING          reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    INT_LIT         reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL_LIT        reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    }               reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 45 (while_stmt -> WHILE ( expr ) stmt .)


state 139

    (46) if_stmt -> IF ( expr ) stmt .
    (47) if_stmt -> IF ( expr ) stmt . ELSE stmt
    CONTINUE        reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    STRING          reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LIT        reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    }               reduce using rule 46 (if_stmt -> IF ( expr ) stmt .)
    ELSE            shift and go to state 143


state 140

    (53) expr -> NEW type_spec [ expr ] .
    ;               reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    %               reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    /               reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    *               reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    -               reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    +               reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    >               reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    GE              reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    <               reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    LE              reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    NE              reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    EQ              reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    AND             reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    OR              reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    )               reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    ,               reduce using rule 53 (expr -> NEW type_spec [ expr ] .)
    ]               reduce using rule 53 (expr -> NEW type_spec [ expr ] .)


state 141

    (84) _5_0x2c_expr_optional -> , expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    )               reduce using rule 84 (_5_0x2c_expr_optional -> , expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90
    AND             shift and go to state 91
    OR              shift and go to state 92


state 142

    (79) expr -> IDENT [ expr ] = . expr
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 144

state 143

    (47) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (37) stmt -> . break_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . if_stmt
    (41) stmt -> . compound_stmt
    (42) stmt -> . expr_stmt
    (51) break_stmt -> . CONTINUE ;
    (52) break_stmt -> . BREAK ;
    (48) return_stmt -> . RETURN _4_expr_optional ;
    (45) while_stmt -> . WHILE ( expr ) stmt
    (46) if_stmt -> . IF ( expr ) stmt
    (47) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (26) compound_stmt -> . { local_decls stmt_list }
    (43) expr_stmt -> . ;
    (44) expr_stmt -> . expr ;
    (53) expr -> . NEW type_spec [ expr ]
    (54) expr -> . STRING
    (55) expr -> . FLOAT_LIT
    (56) expr -> . INT_LIT
    (57) expr -> . BOOL_LIT
    (58) expr -> . IDENT . SIZE
    (59) expr -> . IDENT ( args )
    (60) expr -> . IDENT [ expr ]
    (61) expr -> . IDENT
    (62) expr -> . ( expr )
    (63) expr -> . + expr
    (64) expr -> . - expr
    (65) expr -> . ! expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr > expr
    (72) expr -> . expr GE expr
    (73) expr -> . expr < expr
    (74) expr -> . expr LE expr
    (75) expr -> . expr NE expr
    (76) expr -> . expr EQ expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . IDENT [ expr ] = expr
    (80) expr -> . IDENT = expr
    CONTINUE        shift and go to state 53
    BREAK           shift and go to state 55
    RETURN          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 60
    {               shift and go to state 34
    ;               shift and go to state 54
    NEW             shift and go to state 61
    STRING          shift and go to state 62
    FLOAT_LIT       shift and go to state 63
    INT_LIT         shift and go to state 64
    BOOL_LIT        shift and go to state 65
    IDENT           shift and go to state 66
    (               shift and go to state 58
    +               shift and go to state 67
    -               shift and go to state 68
    !               shift and go to state 69

    expr                           shift and go to state 59
    stmt                           shift and go to state 145
    break_stmt                     shift and go to state 47
    return_stmt                    shift and go to state 48
    while_stmt                     shift and go to state 49
    if_stmt                        shift and go to state 50
    compound_stmt                  shift and go to state 51
    expr_stmt                      shift and go to state 52

state 144

    (79) expr -> IDENT [ expr ] = expr .
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . > expr
    (72) expr -> expr . GE expr
    (73) expr -> expr . < expr
    (74) expr -> expr . LE expr
    (75) expr -> expr . NE expr
    (76) expr -> expr . EQ expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 79 (expr -> IDENT [ expr ] = expr .)
    )               reduce using rule 79 (expr -> IDENT [ expr ] = expr .)
    ,               reduce using rule 79 (expr -> IDENT [ expr ] = expr .)
    ]               reduce using rule 79 (expr -> IDENT [ expr ] = expr .)
    %               shift and go to state 80
    /               shift and go to state 81
    *               shift and go to state 82
    -               shift and go to state 83
    +               shift and go to state 84
    >               shift and go to state 85
    GE              shift and go to state 86
    <               shift and go to state 87
    LE              shift and go to state 88
    NE              shift and go to state 89
    EQ              shift and go to state 90
    AND             shift and go to state 91
    OR              shift and go to state 92


state 145

    (47) if_stmt -> IF ( expr ) stmt ELSE stmt .
    CONTINUE        reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING          reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LIT        reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    }               reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 47 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
