Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> class_decl
Rule 5     decl -> func_decl
Rule 6     decl -> var_decl
Rule 7     var_decl -> type_spec IDENT [ expr ] ;
Rule 8     var_decl -> type_spec IDENT ;
Rule 9     var_decl -> type_spec IDENT = expr ;
Rule 10    type_spec -> CHAR
Rule 11    type_spec -> DOUBLE
Rule 12    type_spec -> FLOAT
Rule 13    type_spec -> INT
Rule 14    type_spec -> BOOL
Rule 15    type_spec -> VOID
Rule 16    func_decl -> type_spec IDENT ( params ) compound_stmt
Rule 17    params -> VOID
Rule 18    params -> param_list
Rule 19    param_list -> param _1_0x2c_param_repeat
Rule 20    _1_0x2c_param_repeat -> _1_0x2c_param_items
Rule 21    _1_0x2c_param_repeat -> <empty>
Rule 22    _1_0x2c_param_items -> _1_0x2c_param_items _1_0x2c_param_item
Rule 23    _1_0x2c_param_items -> _1_0x2c_param_item
Rule 24    _1_0x2c_param_item -> , param
Rule 25    param -> type_spec IDENT [ ]
Rule 26    param -> type_spec IDENT
Rule 27    compound_stmt -> { local_decls stmt_list }
Rule 28    local_decls -> empty
Rule 29    local_decls -> local_decl local_decls
Rule 30    local_decl -> var_decl
Rule 31    stmt_list -> empty
Rule 32    stmt_list -> stmt stmt_list
Rule 33    stmt -> break_stmt
Rule 34    stmt -> return_stmt
Rule 35    stmt -> for_stmt
Rule 36    stmt -> while_stmt
Rule 37    stmt -> if_stmt
Rule 38    stmt -> compound_stmt
Rule 39    stmt -> expr_stmt
Rule 40    class_decl -> CLASS IDENT { var_decl_list }
Rule 41    var_decl_list -> var_decl
Rule 42    var_decl_list -> var_decl_list var_decl
Rule 43    expr_stmt -> SCANF ( expr , args ) ;
Rule 44    expr_stmt -> PRINTF ( expr ) ;
Rule 45    expr_stmt -> PRINTF ( expr , args ) ;
Rule 46    expr_stmt -> ;
Rule 47    expr_stmt -> expr ;
Rule 48    while_stmt -> WHILE ( expr ) stmt
Rule 49    for_stmt -> FOR ( expr ; expr ; expr ) stmt
Rule 50    if_stmt -> IF ( expr ) stmt  [precedence=nonassoc, level=1]
Rule 51    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=nonassoc, level=2]
Rule 52    return_stmt -> RETURN expr ;
Rule 53    break_stmt -> CONTINUE ;
Rule 54    break_stmt -> BREAK ;
Rule 55    expr -> NEW type_spec [ expr ]
Rule 56    expr -> CHAR_LIT
Rule 57    expr -> STRING_LIT
Rule 58    expr -> FLOAT_LIT
Rule 59    expr -> INT_LIT
Rule 60    expr -> BOOL_LIT
Rule 61    expr -> IDENT . SIZE
Rule 62    expr -> IDENT ( args )
Rule 63    expr -> IDENT [ expr ]
Rule 64    expr -> IDENT [ expr ] = expr  [precedence=right, level=3]
Rule 65    expr -> IDENT = expr  [precedence=right, level=3]
Rule 66    expr -> NULL
Rule 67    expr -> IDENT
Rule 68    expr -> ( expr )
Rule 69    expr -> + expr  [precedence=right, level=10]
Rule 70    expr -> - expr  [precedence=right, level=10]
Rule 71    expr -> ! expr  [precedence=right, level=10]
Rule 72    expr -> expr % expr  [precedence=left, level=9]
Rule 73    expr -> expr / expr  [precedence=left, level=9]
Rule 74    expr -> expr * expr  [precedence=left, level=9]
Rule 75    expr -> expr - expr  [precedence=left, level=8]
Rule 76    expr -> expr + expr  [precedence=left, level=8]
Rule 77    expr -> expr > expr  [precedence=left, level=7]
Rule 78    expr -> expr GE expr  [precedence=left, level=7]
Rule 79    expr -> expr < expr  [precedence=left, level=7]
Rule 80    expr -> expr LE expr  [precedence=left, level=7]
Rule 81    expr -> expr NE expr  [precedence=left, level=6]
Rule 82    expr -> expr EQ expr  [precedence=left, level=6]
Rule 83    expr -> expr AND expr  [precedence=left, level=5]
Rule 84    expr -> expr OR expr  [precedence=left, level=4]
Rule 85    expr -> ( type_spec ) expr  [precedence=right, level=11]
Rule 86    args -> empty
Rule 87    args -> arg_list
Rule 88    arg_list -> arg_list , expr
Rule 89    arg_list -> expr
Rule 90    empty -> <empty>

Unused terminals:

    SPRINTF

Terminals, with rules where they appear:

!                    : 71
%                    : 72
(                    : 16 43 44 45 48 49 50 51 62 68 85
)                    : 16 43 44 45 48 49 50 51 62 68 85
*                    : 74
+                    : 69 76
,                    : 24 43 45 88
-                    : 70 75
.                    : 61
/                    : 73
;                    : 7 8 9 43 44 45 46 47 49 49 52 53 54
<                    : 79
=                    : 9 64 65
>                    : 77
AND                  : 83
BOOL                 : 14
BOOL_LIT             : 60
BREAK                : 54
CHAR                 : 10
CHAR_LIT             : 56
CLASS                : 40
CONTINUE             : 53
DOUBLE               : 11
ELSE                 : 51
EQ                   : 82
FLOAT                : 12
FLOAT_LIT            : 58
FOR                  : 49
GE                   : 78
IDENT                : 7 8 9 16 25 26 40 61 62 63 64 65 67
IF                   : 50 51
INT                  : 13
INT_LIT              : 59
LE                   : 80
NE                   : 81
NEW                  : 55
NULL                 : 66
OR                   : 84
PRINTF               : 44 45
RETURN               : 52
SCANF                : 43
SIZE                 : 61
SPRINTF              : 
STRING_LIT           : 57
VOID                 : 15 17
WHILE                : 48
[                    : 7 25 55 63 64
]                    : 7 25 55 63 64
error                : 
{                    : 27 40
}                    : 27 40

Nonterminals, with rules where they appear:

_1_0x2c_param_item   : 22 23
_1_0x2c_param_items  : 20 22
_1_0x2c_param_repeat : 19
arg_list             : 87 88
args                 : 43 45 62
break_stmt           : 33
class_decl           : 4
compound_stmt        : 16 38
decl                 : 2 3
decl_list            : 1 3
empty                : 28 31 86
expr                 : 7 9 43 44 45 47 48 49 49 49 50 51 52 55 63 64 64 65 68 69 70 71 72 72 73 73 74 74 75 75 76 76 77 77 78 78 79 79 80 80 81 81 82 82 83 83 84 84 85 88 89
expr_stmt            : 39
for_stmt             : 35
func_decl            : 5
if_stmt              : 37
local_decl           : 29
local_decls          : 27 29
param                : 19 24
param_list           : 18
params               : 16
program              : 0
return_stmt          : 34
stmt                 : 32 48 49 50 51 51
stmt_list            : 27 32
type_spec            : 7 8 9 16 25 26 55 85
var_decl             : 6 30 41 42
var_decl_list        : 40 42
while_stmt           : 36


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (40) class_decl -> . CLASS IDENT { var_decl_list }
    (16) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (7) var_decl -> . type_spec IDENT [ expr ] ;
    (8) var_decl -> . type_spec IDENT ;
    (9) var_decl -> . type_spec IDENT = expr ;
    (10) type_spec -> . CHAR
    (11) type_spec -> . DOUBLE
    (12) type_spec -> . FLOAT
    (13) type_spec -> . INT
    (14) type_spec -> . BOOL
    (15) type_spec -> . VOID
    CLASS           shift and go to state 7
    CHAR            shift and go to state 9
    DOUBLE          shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13
    VOID            shift and go to state 14

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (40) class_decl -> . CLASS IDENT { var_decl_list }
    (16) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (7) var_decl -> . type_spec IDENT [ expr ] ;
    (8) var_decl -> . type_spec IDENT ;
    (9) var_decl -> . type_spec IDENT = expr ;
    (10) type_spec -> . CHAR
    (11) type_spec -> . DOUBLE
    (12) type_spec -> . FLOAT
    (13) type_spec -> . INT
    (14) type_spec -> . BOOL
    (15) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    CLASS           shift and go to state 7
    CHAR            shift and go to state 9
    DOUBLE          shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13
    VOID            shift and go to state 14

    decl                           shift and go to state 15
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 3

    (2) decl_list -> decl .
    CLASS           reduce using rule 2 (decl_list -> decl .)
    CHAR            reduce using rule 2 (decl_list -> decl .)
    DOUBLE          reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> class_decl .
    CLASS           reduce using rule 4 (decl -> class_decl .)
    CHAR            reduce using rule 4 (decl -> class_decl .)
    DOUBLE          reduce using rule 4 (decl -> class_decl .)
    FLOAT           reduce using rule 4 (decl -> class_decl .)
    INT             reduce using rule 4 (decl -> class_decl .)
    BOOL            reduce using rule 4 (decl -> class_decl .)
    VOID            reduce using rule 4 (decl -> class_decl .)
    $end            reduce using rule 4 (decl -> class_decl .)


state 5

    (5) decl -> func_decl .
    CLASS           reduce using rule 5 (decl -> func_decl .)
    CHAR            reduce using rule 5 (decl -> func_decl .)
    DOUBLE          reduce using rule 5 (decl -> func_decl .)
    FLOAT           reduce using rule 5 (decl -> func_decl .)
    INT             reduce using rule 5 (decl -> func_decl .)
    BOOL            reduce using rule 5 (decl -> func_decl .)
    VOID            reduce using rule 5 (decl -> func_decl .)
    $end            reduce using rule 5 (decl -> func_decl .)


state 6

    (6) decl -> var_decl .
    CLASS           reduce using rule 6 (decl -> var_decl .)
    CHAR            reduce using rule 6 (decl -> var_decl .)
    DOUBLE          reduce using rule 6 (decl -> var_decl .)
    FLOAT           reduce using rule 6 (decl -> var_decl .)
    INT             reduce using rule 6 (decl -> var_decl .)
    BOOL            reduce using rule 6 (decl -> var_decl .)
    VOID            reduce using rule 6 (decl -> var_decl .)
    $end            reduce using rule 6 (decl -> var_decl .)


state 7

    (40) class_decl -> CLASS . IDENT { var_decl_list }
    IDENT           shift and go to state 16


state 8

    (16) func_decl -> type_spec . IDENT ( params ) compound_stmt
    (7) var_decl -> type_spec . IDENT [ expr ] ;
    (8) var_decl -> type_spec . IDENT ;
    (9) var_decl -> type_spec . IDENT = expr ;
    IDENT           shift and go to state 17


state 9

    (10) type_spec -> CHAR .
    IDENT           reduce using rule 10 (type_spec -> CHAR .)
    [               reduce using rule 10 (type_spec -> CHAR .)
    )               reduce using rule 10 (type_spec -> CHAR .)


state 10

    (11) type_spec -> DOUBLE .
    IDENT           reduce using rule 11 (type_spec -> DOUBLE .)
    [               reduce using rule 11 (type_spec -> DOUBLE .)
    )               reduce using rule 11 (type_spec -> DOUBLE .)


state 11

    (12) type_spec -> FLOAT .
    IDENT           reduce using rule 12 (type_spec -> FLOAT .)
    [               reduce using rule 12 (type_spec -> FLOAT .)
    )               reduce using rule 12 (type_spec -> FLOAT .)


state 12

    (13) type_spec -> INT .
    IDENT           reduce using rule 13 (type_spec -> INT .)
    [               reduce using rule 13 (type_spec -> INT .)
    )               reduce using rule 13 (type_spec -> INT .)


state 13

    (14) type_spec -> BOOL .
    IDENT           reduce using rule 14 (type_spec -> BOOL .)
    [               reduce using rule 14 (type_spec -> BOOL .)
    )               reduce using rule 14 (type_spec -> BOOL .)


state 14

    (15) type_spec -> VOID .
    IDENT           reduce using rule 15 (type_spec -> VOID .)
    [               reduce using rule 15 (type_spec -> VOID .)
    )               reduce using rule 15 (type_spec -> VOID .)


state 15

    (3) decl_list -> decl_list decl .
    CLASS           reduce using rule 3 (decl_list -> decl_list decl .)
    CHAR            reduce using rule 3 (decl_list -> decl_list decl .)
    DOUBLE          reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 16

    (40) class_decl -> CLASS IDENT . { var_decl_list }
    {               shift and go to state 18


state 17

    (16) func_decl -> type_spec IDENT . ( params ) compound_stmt
    (7) var_decl -> type_spec IDENT . [ expr ] ;
    (8) var_decl -> type_spec IDENT . ;
    (9) var_decl -> type_spec IDENT . = expr ;
    (               shift and go to state 19
    [               shift and go to state 20
    ;               shift and go to state 21
    =               shift and go to state 22


state 18

    (40) class_decl -> CLASS IDENT { . var_decl_list }
    (41) var_decl_list -> . var_decl
    (42) var_decl_list -> . var_decl_list var_decl
    (7) var_decl -> . type_spec IDENT [ expr ] ;
    (8) var_decl -> . type_spec IDENT ;
    (9) var_decl -> . type_spec IDENT = expr ;
    (10) type_spec -> . CHAR
    (11) type_spec -> . DOUBLE
    (12) type_spec -> . FLOAT
    (13) type_spec -> . INT
    (14) type_spec -> . BOOL
    (15) type_spec -> . VOID
    CHAR            shift and go to state 9
    DOUBLE          shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13
    VOID            shift and go to state 14

    var_decl_list                  shift and go to state 23
    var_decl                       shift and go to state 24
    type_spec                      shift and go to state 25

state 19

    (16) func_decl -> type_spec IDENT ( . params ) compound_stmt
    (17) params -> . VOID
    (18) params -> . param_list
    (19) param_list -> . param _1_0x2c_param_repeat
    (25) param -> . type_spec IDENT [ ]
    (26) param -> . type_spec IDENT
    (10) type_spec -> . CHAR
    (11) type_spec -> . DOUBLE
    (12) type_spec -> . FLOAT
    (13) type_spec -> . INT
    (14) type_spec -> . BOOL
    (15) type_spec -> . VOID
    VOID            shift and go to state 28
    CHAR            shift and go to state 9
    DOUBLE          shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13

    type_spec                      shift and go to state 26
    params                         shift and go to state 27
    param_list                     shift and go to state 29
    param                          shift and go to state 30

state 20

    (7) var_decl -> type_spec IDENT [ . expr ] ;
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 32

state 21

    (8) var_decl -> type_spec IDENT ; .
    CLASS           reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    CHAR            reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    DOUBLE          reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    }               reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    CONTINUE        reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    FOR             reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    IF              reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    {               reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    SCANF           reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    PRINTF          reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    ;               reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    NEW             reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    CHAR_LIT        reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    STRING_LIT      reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    BOOL_LIT        reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    NULL            reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    (               reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    +               reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    -               reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    !               reduce using rule 8 (var_decl -> type_spec IDENT ; .)


state 22

    (9) var_decl -> type_spec IDENT = . expr ;
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 44

state 23

    (40) class_decl -> CLASS IDENT { var_decl_list . }
    (42) var_decl_list -> var_decl_list . var_decl
    (7) var_decl -> . type_spec IDENT [ expr ] ;
    (8) var_decl -> . type_spec IDENT ;
    (9) var_decl -> . type_spec IDENT = expr ;
    (10) type_spec -> . CHAR
    (11) type_spec -> . DOUBLE
    (12) type_spec -> . FLOAT
    (13) type_spec -> . INT
    (14) type_spec -> . BOOL
    (15) type_spec -> . VOID
    }               shift and go to state 45
    CHAR            shift and go to state 9
    DOUBLE          shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13
    VOID            shift and go to state 14

    var_decl                       shift and go to state 46
    type_spec                      shift and go to state 25

state 24

    (41) var_decl_list -> var_decl .
    }               reduce using rule 41 (var_decl_list -> var_decl .)
    CHAR            reduce using rule 41 (var_decl_list -> var_decl .)
    DOUBLE          reduce using rule 41 (var_decl_list -> var_decl .)
    FLOAT           reduce using rule 41 (var_decl_list -> var_decl .)
    INT             reduce using rule 41 (var_decl_list -> var_decl .)
    BOOL            reduce using rule 41 (var_decl_list -> var_decl .)
    VOID            reduce using rule 41 (var_decl_list -> var_decl .)


state 25

    (7) var_decl -> type_spec . IDENT [ expr ] ;
    (8) var_decl -> type_spec . IDENT ;
    (9) var_decl -> type_spec . IDENT = expr ;
    IDENT           shift and go to state 47


state 26

    (25) param -> type_spec . IDENT [ ]
    (26) param -> type_spec . IDENT
    IDENT           shift and go to state 48


state 27

    (16) func_decl -> type_spec IDENT ( params . ) compound_stmt
    )               shift and go to state 49


state 28

    (17) params -> VOID .
    (15) type_spec -> VOID .
    )               reduce using rule 17 (params -> VOID .)
    IDENT           reduce using rule 15 (type_spec -> VOID .)


state 29

    (18) params -> param_list .
    )               reduce using rule 18 (params -> param_list .)


state 30

    (19) param_list -> param . _1_0x2c_param_repeat
    (20) _1_0x2c_param_repeat -> . _1_0x2c_param_items
    (21) _1_0x2c_param_repeat -> .
    (22) _1_0x2c_param_items -> . _1_0x2c_param_items _1_0x2c_param_item
    (23) _1_0x2c_param_items -> . _1_0x2c_param_item
    (24) _1_0x2c_param_item -> . , param
    )               reduce using rule 21 (_1_0x2c_param_repeat -> .)
    ,               shift and go to state 53

    _1_0x2c_param_repeat           shift and go to state 50
    _1_0x2c_param_items            shift and go to state 51
    _1_0x2c_param_item             shift and go to state 52

state 31

    (61) expr -> IDENT . . SIZE
    (62) expr -> IDENT . ( args )
    (63) expr -> IDENT . [ expr ]
    (64) expr -> IDENT . [ expr ] = expr
    (65) expr -> IDENT . = expr
    (67) expr -> IDENT .
    .               shift and go to state 54
    (               shift and go to state 55
    [               shift and go to state 56
    =               shift and go to state 57
    ]               reduce using rule 67 (expr -> IDENT .)
    %               reduce using rule 67 (expr -> IDENT .)
    /               reduce using rule 67 (expr -> IDENT .)
    *               reduce using rule 67 (expr -> IDENT .)
    -               reduce using rule 67 (expr -> IDENT .)
    +               reduce using rule 67 (expr -> IDENT .)
    >               reduce using rule 67 (expr -> IDENT .)
    GE              reduce using rule 67 (expr -> IDENT .)
    <               reduce using rule 67 (expr -> IDENT .)
    LE              reduce using rule 67 (expr -> IDENT .)
    NE              reduce using rule 67 (expr -> IDENT .)
    EQ              reduce using rule 67 (expr -> IDENT .)
    AND             reduce using rule 67 (expr -> IDENT .)
    OR              reduce using rule 67 (expr -> IDENT .)
    ;               reduce using rule 67 (expr -> IDENT .)
    )               reduce using rule 67 (expr -> IDENT .)
    ,               reduce using rule 67 (expr -> IDENT .)


state 32

    (7) var_decl -> type_spec IDENT [ expr . ] ;
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               shift and go to state 58
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 33

    (55) expr -> NEW . type_spec [ expr ]
    (10) type_spec -> . CHAR
    (11) type_spec -> . DOUBLE
    (12) type_spec -> . FLOAT
    (13) type_spec -> . INT
    (14) type_spec -> . BOOL
    (15) type_spec -> . VOID
    CHAR            shift and go to state 9
    DOUBLE          shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13
    VOID            shift and go to state 14

    type_spec                      shift and go to state 72

state 34

    (56) expr -> CHAR_LIT .
    ]               reduce using rule 56 (expr -> CHAR_LIT .)
    %               reduce using rule 56 (expr -> CHAR_LIT .)
    /               reduce using rule 56 (expr -> CHAR_LIT .)
    *               reduce using rule 56 (expr -> CHAR_LIT .)
    -               reduce using rule 56 (expr -> CHAR_LIT .)
    +               reduce using rule 56 (expr -> CHAR_LIT .)
    >               reduce using rule 56 (expr -> CHAR_LIT .)
    GE              reduce using rule 56 (expr -> CHAR_LIT .)
    <               reduce using rule 56 (expr -> CHAR_LIT .)
    LE              reduce using rule 56 (expr -> CHAR_LIT .)
    NE              reduce using rule 56 (expr -> CHAR_LIT .)
    EQ              reduce using rule 56 (expr -> CHAR_LIT .)
    AND             reduce using rule 56 (expr -> CHAR_LIT .)
    OR              reduce using rule 56 (expr -> CHAR_LIT .)
    ;               reduce using rule 56 (expr -> CHAR_LIT .)
    )               reduce using rule 56 (expr -> CHAR_LIT .)
    ,               reduce using rule 56 (expr -> CHAR_LIT .)


state 35

    (57) expr -> STRING_LIT .
    ]               reduce using rule 57 (expr -> STRING_LIT .)
    %               reduce using rule 57 (expr -> STRING_LIT .)
    /               reduce using rule 57 (expr -> STRING_LIT .)
    *               reduce using rule 57 (expr -> STRING_LIT .)
    -               reduce using rule 57 (expr -> STRING_LIT .)
    +               reduce using rule 57 (expr -> STRING_LIT .)
    >               reduce using rule 57 (expr -> STRING_LIT .)
    GE              reduce using rule 57 (expr -> STRING_LIT .)
    <               reduce using rule 57 (expr -> STRING_LIT .)
    LE              reduce using rule 57 (expr -> STRING_LIT .)
    NE              reduce using rule 57 (expr -> STRING_LIT .)
    EQ              reduce using rule 57 (expr -> STRING_LIT .)
    AND             reduce using rule 57 (expr -> STRING_LIT .)
    OR              reduce using rule 57 (expr -> STRING_LIT .)
    ;               reduce using rule 57 (expr -> STRING_LIT .)
    )               reduce using rule 57 (expr -> STRING_LIT .)
    ,               reduce using rule 57 (expr -> STRING_LIT .)


state 36

    (58) expr -> FLOAT_LIT .
    ]               reduce using rule 58 (expr -> FLOAT_LIT .)
    %               reduce using rule 58 (expr -> FLOAT_LIT .)
    /               reduce using rule 58 (expr -> FLOAT_LIT .)
    *               reduce using rule 58 (expr -> FLOAT_LIT .)
    -               reduce using rule 58 (expr -> FLOAT_LIT .)
    +               reduce using rule 58 (expr -> FLOAT_LIT .)
    >               reduce using rule 58 (expr -> FLOAT_LIT .)
    GE              reduce using rule 58 (expr -> FLOAT_LIT .)
    <               reduce using rule 58 (expr -> FLOAT_LIT .)
    LE              reduce using rule 58 (expr -> FLOAT_LIT .)
    NE              reduce using rule 58 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 58 (expr -> FLOAT_LIT .)
    AND             reduce using rule 58 (expr -> FLOAT_LIT .)
    OR              reduce using rule 58 (expr -> FLOAT_LIT .)
    ;               reduce using rule 58 (expr -> FLOAT_LIT .)
    )               reduce using rule 58 (expr -> FLOAT_LIT .)
    ,               reduce using rule 58 (expr -> FLOAT_LIT .)


state 37

    (59) expr -> INT_LIT .
    ]               reduce using rule 59 (expr -> INT_LIT .)
    %               reduce using rule 59 (expr -> INT_LIT .)
    /               reduce using rule 59 (expr -> INT_LIT .)
    *               reduce using rule 59 (expr -> INT_LIT .)
    -               reduce using rule 59 (expr -> INT_LIT .)
    +               reduce using rule 59 (expr -> INT_LIT .)
    >               reduce using rule 59 (expr -> INT_LIT .)
    GE              reduce using rule 59 (expr -> INT_LIT .)
    <               reduce using rule 59 (expr -> INT_LIT .)
    LE              reduce using rule 59 (expr -> INT_LIT .)
    NE              reduce using rule 59 (expr -> INT_LIT .)
    EQ              reduce using rule 59 (expr -> INT_LIT .)
    AND             reduce using rule 59 (expr -> INT_LIT .)
    OR              reduce using rule 59 (expr -> INT_LIT .)
    ;               reduce using rule 59 (expr -> INT_LIT .)
    )               reduce using rule 59 (expr -> INT_LIT .)
    ,               reduce using rule 59 (expr -> INT_LIT .)


state 38

    (60) expr -> BOOL_LIT .
    ]               reduce using rule 60 (expr -> BOOL_LIT .)
    %               reduce using rule 60 (expr -> BOOL_LIT .)
    /               reduce using rule 60 (expr -> BOOL_LIT .)
    *               reduce using rule 60 (expr -> BOOL_LIT .)
    -               reduce using rule 60 (expr -> BOOL_LIT .)
    +               reduce using rule 60 (expr -> BOOL_LIT .)
    >               reduce using rule 60 (expr -> BOOL_LIT .)
    GE              reduce using rule 60 (expr -> BOOL_LIT .)
    <               reduce using rule 60 (expr -> BOOL_LIT .)
    LE              reduce using rule 60 (expr -> BOOL_LIT .)
    NE              reduce using rule 60 (expr -> BOOL_LIT .)
    EQ              reduce using rule 60 (expr -> BOOL_LIT .)
    AND             reduce using rule 60 (expr -> BOOL_LIT .)
    OR              reduce using rule 60 (expr -> BOOL_LIT .)
    ;               reduce using rule 60 (expr -> BOOL_LIT .)
    )               reduce using rule 60 (expr -> BOOL_LIT .)
    ,               reduce using rule 60 (expr -> BOOL_LIT .)


state 39

    (68) expr -> ( . expr )
    (85) expr -> ( . type_spec ) expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    (10) type_spec -> . CHAR
    (11) type_spec -> . DOUBLE
    (12) type_spec -> . FLOAT
    (13) type_spec -> . INT
    (14) type_spec -> . BOOL
    (15) type_spec -> . VOID
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43
    CHAR            shift and go to state 9
    DOUBLE          shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13
    VOID            shift and go to state 14

    expr                           shift and go to state 73
    type_spec                      shift and go to state 74

state 40

    (66) expr -> NULL .
    ]               reduce using rule 66 (expr -> NULL .)
    %               reduce using rule 66 (expr -> NULL .)
    /               reduce using rule 66 (expr -> NULL .)
    *               reduce using rule 66 (expr -> NULL .)
    -               reduce using rule 66 (expr -> NULL .)
    +               reduce using rule 66 (expr -> NULL .)
    >               reduce using rule 66 (expr -> NULL .)
    GE              reduce using rule 66 (expr -> NULL .)
    <               reduce using rule 66 (expr -> NULL .)
    LE              reduce using rule 66 (expr -> NULL .)
    NE              reduce using rule 66 (expr -> NULL .)
    EQ              reduce using rule 66 (expr -> NULL .)
    AND             reduce using rule 66 (expr -> NULL .)
    OR              reduce using rule 66 (expr -> NULL .)
    ;               reduce using rule 66 (expr -> NULL .)
    )               reduce using rule 66 (expr -> NULL .)
    ,               reduce using rule 66 (expr -> NULL .)


state 41

    (69) expr -> + . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 75

state 42

    (70) expr -> - . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 76

state 43

    (71) expr -> ! . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 77

state 44

    (9) var_decl -> type_spec IDENT = expr . ;
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ;               shift and go to state 78
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 45

    (40) class_decl -> CLASS IDENT { var_decl_list } .
    CLASS           reduce using rule 40 (class_decl -> CLASS IDENT { var_decl_list } .)
    CHAR            reduce using rule 40 (class_decl -> CLASS IDENT { var_decl_list } .)
    DOUBLE          reduce using rule 40 (class_decl -> CLASS IDENT { var_decl_list } .)
    FLOAT           reduce using rule 40 (class_decl -> CLASS IDENT { var_decl_list } .)
    INT             reduce using rule 40 (class_decl -> CLASS IDENT { var_decl_list } .)
    BOOL            reduce using rule 40 (class_decl -> CLASS IDENT { var_decl_list } .)
    VOID            reduce using rule 40 (class_decl -> CLASS IDENT { var_decl_list } .)
    $end            reduce using rule 40 (class_decl -> CLASS IDENT { var_decl_list } .)


state 46

    (42) var_decl_list -> var_decl_list var_decl .
    }               reduce using rule 42 (var_decl_list -> var_decl_list var_decl .)
    CHAR            reduce using rule 42 (var_decl_list -> var_decl_list var_decl .)
    DOUBLE          reduce using rule 42 (var_decl_list -> var_decl_list var_decl .)
    FLOAT           reduce using rule 42 (var_decl_list -> var_decl_list var_decl .)
    INT             reduce using rule 42 (var_decl_list -> var_decl_list var_decl .)
    BOOL            reduce using rule 42 (var_decl_list -> var_decl_list var_decl .)
    VOID            reduce using rule 42 (var_decl_list -> var_decl_list var_decl .)


state 47

    (7) var_decl -> type_spec IDENT . [ expr ] ;
    (8) var_decl -> type_spec IDENT . ;
    (9) var_decl -> type_spec IDENT . = expr ;
    [               shift and go to state 20
    ;               shift and go to state 21
    =               shift and go to state 22


state 48

    (25) param -> type_spec IDENT . [ ]
    (26) param -> type_spec IDENT .
    [               shift and go to state 79
    ,               reduce using rule 26 (param -> type_spec IDENT .)
    )               reduce using rule 26 (param -> type_spec IDENT .)


state 49

    (16) func_decl -> type_spec IDENT ( params ) . compound_stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 81

    compound_stmt                  shift and go to state 80

state 50

    (19) param_list -> param _1_0x2c_param_repeat .
    )               reduce using rule 19 (param_list -> param _1_0x2c_param_repeat .)


state 51

    (20) _1_0x2c_param_repeat -> _1_0x2c_param_items .
    (22) _1_0x2c_param_items -> _1_0x2c_param_items . _1_0x2c_param_item
    (24) _1_0x2c_param_item -> . , param
    )               reduce using rule 20 (_1_0x2c_param_repeat -> _1_0x2c_param_items .)
    ,               shift and go to state 53

    _1_0x2c_param_item             shift and go to state 82

state 52

    (23) _1_0x2c_param_items -> _1_0x2c_param_item .
    ,               reduce using rule 23 (_1_0x2c_param_items -> _1_0x2c_param_item .)
    )               reduce using rule 23 (_1_0x2c_param_items -> _1_0x2c_param_item .)


state 53

    (24) _1_0x2c_param_item -> , . param
    (25) param -> . type_spec IDENT [ ]
    (26) param -> . type_spec IDENT
    (10) type_spec -> . CHAR
    (11) type_spec -> . DOUBLE
    (12) type_spec -> . FLOAT
    (13) type_spec -> . INT
    (14) type_spec -> . BOOL
    (15) type_spec -> . VOID
    CHAR            shift and go to state 9
    DOUBLE          shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13
    VOID            shift and go to state 14

    param                          shift and go to state 83
    type_spec                      shift and go to state 26

state 54

    (61) expr -> IDENT . . SIZE
    SIZE            shift and go to state 84


state 55

    (62) expr -> IDENT ( . args )
    (86) args -> . empty
    (87) args -> . arg_list
    (90) empty -> .
    (88) arg_list -> . arg_list , expr
    (89) arg_list -> . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    )               reduce using rule 90 (empty -> .)
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    args                           shift and go to state 85
    empty                          shift and go to state 86
    arg_list                       shift and go to state 87
    expr                           shift and go to state 88

state 56

    (63) expr -> IDENT [ . expr ]
    (64) expr -> IDENT [ . expr ] = expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 89

state 57

    (65) expr -> IDENT = . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 90

state 58

    (7) var_decl -> type_spec IDENT [ expr ] . ;
    ;               shift and go to state 91


state 59

    (72) expr -> expr % . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 92

state 60

    (73) expr -> expr / . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 93

state 61

    (74) expr -> expr * . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 94

state 62

    (75) expr -> expr - . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 95

state 63

    (76) expr -> expr + . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 96

state 64

    (77) expr -> expr > . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 97

state 65

    (78) expr -> expr GE . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 98

state 66

    (79) expr -> expr < . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 99

state 67

    (80) expr -> expr LE . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 100

state 68

    (81) expr -> expr NE . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 101

state 69

    (82) expr -> expr EQ . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 102

state 70

    (83) expr -> expr AND . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 103

state 71

    (84) expr -> expr OR . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 104

state 72

    (55) expr -> NEW type_spec . [ expr ]
    [               shift and go to state 105


state 73

    (68) expr -> ( expr . )
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    )               shift and go to state 106
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 74

    (85) expr -> ( type_spec . ) expr
    )               shift and go to state 107


state 75

    (69) expr -> + expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 69 (expr -> + expr .)
    %               reduce using rule 69 (expr -> + expr .)
    /               reduce using rule 69 (expr -> + expr .)
    *               reduce using rule 69 (expr -> + expr .)
    -               reduce using rule 69 (expr -> + expr .)
    +               reduce using rule 69 (expr -> + expr .)
    >               reduce using rule 69 (expr -> + expr .)
    GE              reduce using rule 69 (expr -> + expr .)
    <               reduce using rule 69 (expr -> + expr .)
    LE              reduce using rule 69 (expr -> + expr .)
    NE              reduce using rule 69 (expr -> + expr .)
    EQ              reduce using rule 69 (expr -> + expr .)
    AND             reduce using rule 69 (expr -> + expr .)
    OR              reduce using rule 69 (expr -> + expr .)
    ;               reduce using rule 69 (expr -> + expr .)
    )               reduce using rule 69 (expr -> + expr .)
    ,               reduce using rule 69 (expr -> + expr .)


state 76

    (70) expr -> - expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 70 (expr -> - expr .)
    %               reduce using rule 70 (expr -> - expr .)
    /               reduce using rule 70 (expr -> - expr .)
    *               reduce using rule 70 (expr -> - expr .)
    -               reduce using rule 70 (expr -> - expr .)
    +               reduce using rule 70 (expr -> - expr .)
    >               reduce using rule 70 (expr -> - expr .)
    GE              reduce using rule 70 (expr -> - expr .)
    <               reduce using rule 70 (expr -> - expr .)
    LE              reduce using rule 70 (expr -> - expr .)
    NE              reduce using rule 70 (expr -> - expr .)
    EQ              reduce using rule 70 (expr -> - expr .)
    AND             reduce using rule 70 (expr -> - expr .)
    OR              reduce using rule 70 (expr -> - expr .)
    ;               reduce using rule 70 (expr -> - expr .)
    )               reduce using rule 70 (expr -> - expr .)
    ,               reduce using rule 70 (expr -> - expr .)


state 77

    (71) expr -> ! expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 71 (expr -> ! expr .)
    %               reduce using rule 71 (expr -> ! expr .)
    /               reduce using rule 71 (expr -> ! expr .)
    *               reduce using rule 71 (expr -> ! expr .)
    -               reduce using rule 71 (expr -> ! expr .)
    +               reduce using rule 71 (expr -> ! expr .)
    >               reduce using rule 71 (expr -> ! expr .)
    GE              reduce using rule 71 (expr -> ! expr .)
    <               reduce using rule 71 (expr -> ! expr .)
    LE              reduce using rule 71 (expr -> ! expr .)
    NE              reduce using rule 71 (expr -> ! expr .)
    EQ              reduce using rule 71 (expr -> ! expr .)
    AND             reduce using rule 71 (expr -> ! expr .)
    OR              reduce using rule 71 (expr -> ! expr .)
    ;               reduce using rule 71 (expr -> ! expr .)
    )               reduce using rule 71 (expr -> ! expr .)
    ,               reduce using rule 71 (expr -> ! expr .)


state 78

    (9) var_decl -> type_spec IDENT = expr ; .
    CLASS           reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    CHAR            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    DOUBLE          reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    FLOAT           reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    INT             reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    BOOL            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    VOID            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    $end            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    }               reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    CONTINUE        reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    BREAK           reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    RETURN          reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    FOR             reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    WHILE           reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    IF              reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    {               reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    SCANF           reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    PRINTF          reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    ;               reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    NEW             reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    CHAR_LIT        reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    STRING_LIT      reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    FLOAT_LIT       reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    INT_LIT         reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    BOOL_LIT        reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    IDENT           reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    NULL            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    (               reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    +               reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    -               reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    !               reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)


state 79

    (25) param -> type_spec IDENT [ . ]
    ]               shift and go to state 108


state 80

    (16) func_decl -> type_spec IDENT ( params ) compound_stmt .
    CLASS           reduce using rule 16 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    CHAR            reduce using rule 16 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    DOUBLE          reduce using rule 16 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    FLOAT           reduce using rule 16 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    INT             reduce using rule 16 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    BOOL            reduce using rule 16 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    VOID            reduce using rule 16 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    $end            reduce using rule 16 (func_decl -> type_spec IDENT ( params ) compound_stmt .)


state 81

    (27) compound_stmt -> { . local_decls stmt_list }
    (28) local_decls -> . empty
    (29) local_decls -> . local_decl local_decls
    (90) empty -> .
    (30) local_decl -> . var_decl
    (7) var_decl -> . type_spec IDENT [ expr ] ;
    (8) var_decl -> . type_spec IDENT ;
    (9) var_decl -> . type_spec IDENT = expr ;
    (10) type_spec -> . CHAR
    (11) type_spec -> . DOUBLE
    (12) type_spec -> . FLOAT
    (13) type_spec -> . INT
    (14) type_spec -> . BOOL
    (15) type_spec -> . VOID
    CONTINUE        reduce using rule 90 (empty -> .)
    BREAK           reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    WHILE           reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    {               reduce using rule 90 (empty -> .)
    SCANF           reduce using rule 90 (empty -> .)
    PRINTF          reduce using rule 90 (empty -> .)
    ;               reduce using rule 90 (empty -> .)
    NEW             reduce using rule 90 (empty -> .)
    CHAR_LIT        reduce using rule 90 (empty -> .)
    STRING_LIT      reduce using rule 90 (empty -> .)
    FLOAT_LIT       reduce using rule 90 (empty -> .)
    INT_LIT         reduce using rule 90 (empty -> .)
    BOOL_LIT        reduce using rule 90 (empty -> .)
    IDENT           reduce using rule 90 (empty -> .)
    NULL            reduce using rule 90 (empty -> .)
    (               reduce using rule 90 (empty -> .)
    +               reduce using rule 90 (empty -> .)
    -               reduce using rule 90 (empty -> .)
    !               reduce using rule 90 (empty -> .)
    }               reduce using rule 90 (empty -> .)
    CHAR            shift and go to state 9
    DOUBLE          shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13
    VOID            shift and go to state 14

    local_decls                    shift and go to state 109
    empty                          shift and go to state 110
    local_decl                     shift and go to state 111
    var_decl                       shift and go to state 112
    type_spec                      shift and go to state 25

state 82

    (22) _1_0x2c_param_items -> _1_0x2c_param_items _1_0x2c_param_item .
    ,               reduce using rule 22 (_1_0x2c_param_items -> _1_0x2c_param_items _1_0x2c_param_item .)
    )               reduce using rule 22 (_1_0x2c_param_items -> _1_0x2c_param_items _1_0x2c_param_item .)


state 83

    (24) _1_0x2c_param_item -> , param .
    ,               reduce using rule 24 (_1_0x2c_param_item -> , param .)
    )               reduce using rule 24 (_1_0x2c_param_item -> , param .)


state 84

    (61) expr -> IDENT . SIZE .
    ]               reduce using rule 61 (expr -> IDENT . SIZE .)
    %               reduce using rule 61 (expr -> IDENT . SIZE .)
    /               reduce using rule 61 (expr -> IDENT . SIZE .)
    *               reduce using rule 61 (expr -> IDENT . SIZE .)
    -               reduce using rule 61 (expr -> IDENT . SIZE .)
    +               reduce using rule 61 (expr -> IDENT . SIZE .)
    >               reduce using rule 61 (expr -> IDENT . SIZE .)
    GE              reduce using rule 61 (expr -> IDENT . SIZE .)
    <               reduce using rule 61 (expr -> IDENT . SIZE .)
    LE              reduce using rule 61 (expr -> IDENT . SIZE .)
    NE              reduce using rule 61 (expr -> IDENT . SIZE .)
    EQ              reduce using rule 61 (expr -> IDENT . SIZE .)
    AND             reduce using rule 61 (expr -> IDENT . SIZE .)
    OR              reduce using rule 61 (expr -> IDENT . SIZE .)
    ;               reduce using rule 61 (expr -> IDENT . SIZE .)
    )               reduce using rule 61 (expr -> IDENT . SIZE .)
    ,               reduce using rule 61 (expr -> IDENT . SIZE .)


state 85

    (62) expr -> IDENT ( args . )
    )               shift and go to state 113


state 86

    (86) args -> empty .
    )               reduce using rule 86 (args -> empty .)


state 87

    (87) args -> arg_list .
    (88) arg_list -> arg_list . , expr
    )               reduce using rule 87 (args -> arg_list .)
    ,               shift and go to state 114


state 88

    (89) arg_list -> expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ,               reduce using rule 89 (arg_list -> expr .)
    )               reduce using rule 89 (arg_list -> expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 89

    (63) expr -> IDENT [ expr . ]
    (64) expr -> IDENT [ expr . ] = expr
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               shift and go to state 115
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 90

    (65) expr -> IDENT = expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 65 (expr -> IDENT = expr .)
    ;               reduce using rule 65 (expr -> IDENT = expr .)
    )               reduce using rule 65 (expr -> IDENT = expr .)
    ,               reduce using rule 65 (expr -> IDENT = expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 91

    (7) var_decl -> type_spec IDENT [ expr ] ; .
    CLASS           reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    CHAR            reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    DOUBLE          reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    FLOAT           reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    INT             reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    BOOL            reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    VOID            reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    $end            reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    }               reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    CONTINUE        reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    BREAK           reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    RETURN          reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    FOR             reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    WHILE           reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    IF              reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    {               reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    SCANF           reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    PRINTF          reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    ;               reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    NEW             reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    CHAR_LIT        reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    STRING_LIT      reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    FLOAT_LIT       reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    INT_LIT         reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    BOOL_LIT        reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    IDENT           reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    NULL            reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    (               reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    +               reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    -               reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)
    !               reduce using rule 7 (var_decl -> type_spec IDENT [ expr ] ; .)


state 92

    (72) expr -> expr % expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 72 (expr -> expr % expr .)
    %               reduce using rule 72 (expr -> expr % expr .)
    /               reduce using rule 72 (expr -> expr % expr .)
    *               reduce using rule 72 (expr -> expr % expr .)
    -               reduce using rule 72 (expr -> expr % expr .)
    +               reduce using rule 72 (expr -> expr % expr .)
    >               reduce using rule 72 (expr -> expr % expr .)
    GE              reduce using rule 72 (expr -> expr % expr .)
    <               reduce using rule 72 (expr -> expr % expr .)
    LE              reduce using rule 72 (expr -> expr % expr .)
    NE              reduce using rule 72 (expr -> expr % expr .)
    EQ              reduce using rule 72 (expr -> expr % expr .)
    AND             reduce using rule 72 (expr -> expr % expr .)
    OR              reduce using rule 72 (expr -> expr % expr .)
    ;               reduce using rule 72 (expr -> expr % expr .)
    )               reduce using rule 72 (expr -> expr % expr .)
    ,               reduce using rule 72 (expr -> expr % expr .)


state 93

    (73) expr -> expr / expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 73 (expr -> expr / expr .)
    %               reduce using rule 73 (expr -> expr / expr .)
    /               reduce using rule 73 (expr -> expr / expr .)
    *               reduce using rule 73 (expr -> expr / expr .)
    -               reduce using rule 73 (expr -> expr / expr .)
    +               reduce using rule 73 (expr -> expr / expr .)
    >               reduce using rule 73 (expr -> expr / expr .)
    GE              reduce using rule 73 (expr -> expr / expr .)
    <               reduce using rule 73 (expr -> expr / expr .)
    LE              reduce using rule 73 (expr -> expr / expr .)
    NE              reduce using rule 73 (expr -> expr / expr .)
    EQ              reduce using rule 73 (expr -> expr / expr .)
    AND             reduce using rule 73 (expr -> expr / expr .)
    OR              reduce using rule 73 (expr -> expr / expr .)
    ;               reduce using rule 73 (expr -> expr / expr .)
    )               reduce using rule 73 (expr -> expr / expr .)
    ,               reduce using rule 73 (expr -> expr / expr .)


state 94

    (74) expr -> expr * expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 74 (expr -> expr * expr .)
    %               reduce using rule 74 (expr -> expr * expr .)
    /               reduce using rule 74 (expr -> expr * expr .)
    *               reduce using rule 74 (expr -> expr * expr .)
    -               reduce using rule 74 (expr -> expr * expr .)
    +               reduce using rule 74 (expr -> expr * expr .)
    >               reduce using rule 74 (expr -> expr * expr .)
    GE              reduce using rule 74 (expr -> expr * expr .)
    <               reduce using rule 74 (expr -> expr * expr .)
    LE              reduce using rule 74 (expr -> expr * expr .)
    NE              reduce using rule 74 (expr -> expr * expr .)
    EQ              reduce using rule 74 (expr -> expr * expr .)
    AND             reduce using rule 74 (expr -> expr * expr .)
    OR              reduce using rule 74 (expr -> expr * expr .)
    ;               reduce using rule 74 (expr -> expr * expr .)
    )               reduce using rule 74 (expr -> expr * expr .)
    ,               reduce using rule 74 (expr -> expr * expr .)


state 95

    (75) expr -> expr - expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 75 (expr -> expr - expr .)
    -               reduce using rule 75 (expr -> expr - expr .)
    +               reduce using rule 75 (expr -> expr - expr .)
    >               reduce using rule 75 (expr -> expr - expr .)
    GE              reduce using rule 75 (expr -> expr - expr .)
    <               reduce using rule 75 (expr -> expr - expr .)
    LE              reduce using rule 75 (expr -> expr - expr .)
    NE              reduce using rule 75 (expr -> expr - expr .)
    EQ              reduce using rule 75 (expr -> expr - expr .)
    AND             reduce using rule 75 (expr -> expr - expr .)
    OR              reduce using rule 75 (expr -> expr - expr .)
    ;               reduce using rule 75 (expr -> expr - expr .)
    )               reduce using rule 75 (expr -> expr - expr .)
    ,               reduce using rule 75 (expr -> expr - expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61


state 96

    (76) expr -> expr + expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 76 (expr -> expr + expr .)
    -               reduce using rule 76 (expr -> expr + expr .)
    +               reduce using rule 76 (expr -> expr + expr .)
    >               reduce using rule 76 (expr -> expr + expr .)
    GE              reduce using rule 76 (expr -> expr + expr .)
    <               reduce using rule 76 (expr -> expr + expr .)
    LE              reduce using rule 76 (expr -> expr + expr .)
    NE              reduce using rule 76 (expr -> expr + expr .)
    EQ              reduce using rule 76 (expr -> expr + expr .)
    AND             reduce using rule 76 (expr -> expr + expr .)
    OR              reduce using rule 76 (expr -> expr + expr .)
    ;               reduce using rule 76 (expr -> expr + expr .)
    )               reduce using rule 76 (expr -> expr + expr .)
    ,               reduce using rule 76 (expr -> expr + expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61


state 97

    (77) expr -> expr > expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 77 (expr -> expr > expr .)
    >               reduce using rule 77 (expr -> expr > expr .)
    GE              reduce using rule 77 (expr -> expr > expr .)
    <               reduce using rule 77 (expr -> expr > expr .)
    LE              reduce using rule 77 (expr -> expr > expr .)
    NE              reduce using rule 77 (expr -> expr > expr .)
    EQ              reduce using rule 77 (expr -> expr > expr .)
    AND             reduce using rule 77 (expr -> expr > expr .)
    OR              reduce using rule 77 (expr -> expr > expr .)
    ;               reduce using rule 77 (expr -> expr > expr .)
    )               reduce using rule 77 (expr -> expr > expr .)
    ,               reduce using rule 77 (expr -> expr > expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63


state 98

    (78) expr -> expr GE expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 78 (expr -> expr GE expr .)
    >               reduce using rule 78 (expr -> expr GE expr .)
    GE              reduce using rule 78 (expr -> expr GE expr .)
    <               reduce using rule 78 (expr -> expr GE expr .)
    LE              reduce using rule 78 (expr -> expr GE expr .)
    NE              reduce using rule 78 (expr -> expr GE expr .)
    EQ              reduce using rule 78 (expr -> expr GE expr .)
    AND             reduce using rule 78 (expr -> expr GE expr .)
    OR              reduce using rule 78 (expr -> expr GE expr .)
    ;               reduce using rule 78 (expr -> expr GE expr .)
    )               reduce using rule 78 (expr -> expr GE expr .)
    ,               reduce using rule 78 (expr -> expr GE expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63


state 99

    (79) expr -> expr < expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 79 (expr -> expr < expr .)
    >               reduce using rule 79 (expr -> expr < expr .)
    GE              reduce using rule 79 (expr -> expr < expr .)
    <               reduce using rule 79 (expr -> expr < expr .)
    LE              reduce using rule 79 (expr -> expr < expr .)
    NE              reduce using rule 79 (expr -> expr < expr .)
    EQ              reduce using rule 79 (expr -> expr < expr .)
    AND             reduce using rule 79 (expr -> expr < expr .)
    OR              reduce using rule 79 (expr -> expr < expr .)
    ;               reduce using rule 79 (expr -> expr < expr .)
    )               reduce using rule 79 (expr -> expr < expr .)
    ,               reduce using rule 79 (expr -> expr < expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63


state 100

    (80) expr -> expr LE expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 80 (expr -> expr LE expr .)
    >               reduce using rule 80 (expr -> expr LE expr .)
    GE              reduce using rule 80 (expr -> expr LE expr .)
    <               reduce using rule 80 (expr -> expr LE expr .)
    LE              reduce using rule 80 (expr -> expr LE expr .)
    NE              reduce using rule 80 (expr -> expr LE expr .)
    EQ              reduce using rule 80 (expr -> expr LE expr .)
    AND             reduce using rule 80 (expr -> expr LE expr .)
    OR              reduce using rule 80 (expr -> expr LE expr .)
    ;               reduce using rule 80 (expr -> expr LE expr .)
    )               reduce using rule 80 (expr -> expr LE expr .)
    ,               reduce using rule 80 (expr -> expr LE expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63


state 101

    (81) expr -> expr NE expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 81 (expr -> expr NE expr .)
    NE              reduce using rule 81 (expr -> expr NE expr .)
    EQ              reduce using rule 81 (expr -> expr NE expr .)
    AND             reduce using rule 81 (expr -> expr NE expr .)
    OR              reduce using rule 81 (expr -> expr NE expr .)
    ;               reduce using rule 81 (expr -> expr NE expr .)
    )               reduce using rule 81 (expr -> expr NE expr .)
    ,               reduce using rule 81 (expr -> expr NE expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67


state 102

    (82) expr -> expr EQ expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 82 (expr -> expr EQ expr .)
    NE              reduce using rule 82 (expr -> expr EQ expr .)
    EQ              reduce using rule 82 (expr -> expr EQ expr .)
    AND             reduce using rule 82 (expr -> expr EQ expr .)
    OR              reduce using rule 82 (expr -> expr EQ expr .)
    ;               reduce using rule 82 (expr -> expr EQ expr .)
    )               reduce using rule 82 (expr -> expr EQ expr .)
    ,               reduce using rule 82 (expr -> expr EQ expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67


state 103

    (83) expr -> expr AND expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 83 (expr -> expr AND expr .)
    AND             reduce using rule 83 (expr -> expr AND expr .)
    OR              reduce using rule 83 (expr -> expr AND expr .)
    ;               reduce using rule 83 (expr -> expr AND expr .)
    )               reduce using rule 83 (expr -> expr AND expr .)
    ,               reduce using rule 83 (expr -> expr AND expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69


state 104

    (84) expr -> expr OR expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 84 (expr -> expr OR expr .)
    OR              reduce using rule 84 (expr -> expr OR expr .)
    ;               reduce using rule 84 (expr -> expr OR expr .)
    )               reduce using rule 84 (expr -> expr OR expr .)
    ,               reduce using rule 84 (expr -> expr OR expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70


state 105

    (55) expr -> NEW type_spec [ . expr ]
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 116

state 106

    (68) expr -> ( expr ) .
    ]               reduce using rule 68 (expr -> ( expr ) .)
    %               reduce using rule 68 (expr -> ( expr ) .)
    /               reduce using rule 68 (expr -> ( expr ) .)
    *               reduce using rule 68 (expr -> ( expr ) .)
    -               reduce using rule 68 (expr -> ( expr ) .)
    +               reduce using rule 68 (expr -> ( expr ) .)
    >               reduce using rule 68 (expr -> ( expr ) .)
    GE              reduce using rule 68 (expr -> ( expr ) .)
    <               reduce using rule 68 (expr -> ( expr ) .)
    LE              reduce using rule 68 (expr -> ( expr ) .)
    NE              reduce using rule 68 (expr -> ( expr ) .)
    EQ              reduce using rule 68 (expr -> ( expr ) .)
    AND             reduce using rule 68 (expr -> ( expr ) .)
    OR              reduce using rule 68 (expr -> ( expr ) .)
    ;               reduce using rule 68 (expr -> ( expr ) .)
    )               reduce using rule 68 (expr -> ( expr ) .)
    ,               reduce using rule 68 (expr -> ( expr ) .)


state 107

    (85) expr -> ( type_spec ) . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 117

state 108

    (25) param -> type_spec IDENT [ ] .
    ,               reduce using rule 25 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 25 (param -> type_spec IDENT [ ] .)


state 109

    (27) compound_stmt -> { local_decls . stmt_list }
    (31) stmt_list -> . empty
    (32) stmt_list -> . stmt stmt_list
    (90) empty -> .
    (33) stmt -> . break_stmt
    (34) stmt -> . return_stmt
    (35) stmt -> . for_stmt
    (36) stmt -> . while_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . compound_stmt
    (39) stmt -> . expr_stmt
    (53) break_stmt -> . CONTINUE ;
    (54) break_stmt -> . BREAK ;
    (52) return_stmt -> . RETURN expr ;
    (49) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (48) while_stmt -> . WHILE ( expr ) stmt
    (50) if_stmt -> . IF ( expr ) stmt
    (51) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    (43) expr_stmt -> . SCANF ( expr , args ) ;
    (44) expr_stmt -> . PRINTF ( expr ) ;
    (45) expr_stmt -> . PRINTF ( expr , args ) ;
    (46) expr_stmt -> . ;
    (47) expr_stmt -> . expr ;
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    }               reduce using rule 90 (empty -> .)
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 130
    RETURN          shift and go to state 131
    FOR             shift and go to state 133
    WHILE           shift and go to state 134
    IF              shift and go to state 135
    {               shift and go to state 81
    SCANF           shift and go to state 136
    PRINTF          shift and go to state 137
    ;               shift and go to state 129
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    stmt_list                      shift and go to state 118
    empty                          shift and go to state 119
    stmt                           shift and go to state 120
    break_stmt                     shift and go to state 121
    return_stmt                    shift and go to state 122
    for_stmt                       shift and go to state 123
    while_stmt                     shift and go to state 124
    if_stmt                        shift and go to state 125
    compound_stmt                  shift and go to state 126
    expr_stmt                      shift and go to state 127
    expr                           shift and go to state 132

state 110

    (28) local_decls -> empty .
    CONTINUE        reduce using rule 28 (local_decls -> empty .)
    BREAK           reduce using rule 28 (local_decls -> empty .)
    RETURN          reduce using rule 28 (local_decls -> empty .)
    FOR             reduce using rule 28 (local_decls -> empty .)
    WHILE           reduce using rule 28 (local_decls -> empty .)
    IF              reduce using rule 28 (local_decls -> empty .)
    {               reduce using rule 28 (local_decls -> empty .)
    SCANF           reduce using rule 28 (local_decls -> empty .)
    PRINTF          reduce using rule 28 (local_decls -> empty .)
    ;               reduce using rule 28 (local_decls -> empty .)
    NEW             reduce using rule 28 (local_decls -> empty .)
    CHAR_LIT        reduce using rule 28 (local_decls -> empty .)
    STRING_LIT      reduce using rule 28 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 28 (local_decls -> empty .)
    INT_LIT         reduce using rule 28 (local_decls -> empty .)
    BOOL_LIT        reduce using rule 28 (local_decls -> empty .)
    IDENT           reduce using rule 28 (local_decls -> empty .)
    NULL            reduce using rule 28 (local_decls -> empty .)
    (               reduce using rule 28 (local_decls -> empty .)
    +               reduce using rule 28 (local_decls -> empty .)
    -               reduce using rule 28 (local_decls -> empty .)
    !               reduce using rule 28 (local_decls -> empty .)
    }               reduce using rule 28 (local_decls -> empty .)


state 111

    (29) local_decls -> local_decl . local_decls
    (28) local_decls -> . empty
    (29) local_decls -> . local_decl local_decls
    (90) empty -> .
    (30) local_decl -> . var_decl
    (7) var_decl -> . type_spec IDENT [ expr ] ;
    (8) var_decl -> . type_spec IDENT ;
    (9) var_decl -> . type_spec IDENT = expr ;
    (10) type_spec -> . CHAR
    (11) type_spec -> . DOUBLE
    (12) type_spec -> . FLOAT
    (13) type_spec -> . INT
    (14) type_spec -> . BOOL
    (15) type_spec -> . VOID
    CONTINUE        reduce using rule 90 (empty -> .)
    BREAK           reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    WHILE           reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    {               reduce using rule 90 (empty -> .)
    SCANF           reduce using rule 90 (empty -> .)
    PRINTF          reduce using rule 90 (empty -> .)
    ;               reduce using rule 90 (empty -> .)
    NEW             reduce using rule 90 (empty -> .)
    CHAR_LIT        reduce using rule 90 (empty -> .)
    STRING_LIT      reduce using rule 90 (empty -> .)
    FLOAT_LIT       reduce using rule 90 (empty -> .)
    INT_LIT         reduce using rule 90 (empty -> .)
    BOOL_LIT        reduce using rule 90 (empty -> .)
    IDENT           reduce using rule 90 (empty -> .)
    NULL            reduce using rule 90 (empty -> .)
    (               reduce using rule 90 (empty -> .)
    +               reduce using rule 90 (empty -> .)
    -               reduce using rule 90 (empty -> .)
    !               reduce using rule 90 (empty -> .)
    }               reduce using rule 90 (empty -> .)
    CHAR            shift and go to state 9
    DOUBLE          shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13
    VOID            shift and go to state 14

    local_decl                     shift and go to state 111
    local_decls                    shift and go to state 138
    empty                          shift and go to state 110
    var_decl                       shift and go to state 112
    type_spec                      shift and go to state 25

state 112

    (30) local_decl -> var_decl .
    CHAR            reduce using rule 30 (local_decl -> var_decl .)
    DOUBLE          reduce using rule 30 (local_decl -> var_decl .)
    FLOAT           reduce using rule 30 (local_decl -> var_decl .)
    INT             reduce using rule 30 (local_decl -> var_decl .)
    BOOL            reduce using rule 30 (local_decl -> var_decl .)
    VOID            reduce using rule 30 (local_decl -> var_decl .)
    CONTINUE        reduce using rule 30 (local_decl -> var_decl .)
    BREAK           reduce using rule 30 (local_decl -> var_decl .)
    RETURN          reduce using rule 30 (local_decl -> var_decl .)
    FOR             reduce using rule 30 (local_decl -> var_decl .)
    WHILE           reduce using rule 30 (local_decl -> var_decl .)
    IF              reduce using rule 30 (local_decl -> var_decl .)
    {               reduce using rule 30 (local_decl -> var_decl .)
    SCANF           reduce using rule 30 (local_decl -> var_decl .)
    PRINTF          reduce using rule 30 (local_decl -> var_decl .)
    ;               reduce using rule 30 (local_decl -> var_decl .)
    NEW             reduce using rule 30 (local_decl -> var_decl .)
    CHAR_LIT        reduce using rule 30 (local_decl -> var_decl .)
    STRING_LIT      reduce using rule 30 (local_decl -> var_decl .)
    FLOAT_LIT       reduce using rule 30 (local_decl -> var_decl .)
    INT_LIT         reduce using rule 30 (local_decl -> var_decl .)
    BOOL_LIT        reduce using rule 30 (local_decl -> var_decl .)
    IDENT           reduce using rule 30 (local_decl -> var_decl .)
    NULL            reduce using rule 30 (local_decl -> var_decl .)
    (               reduce using rule 30 (local_decl -> var_decl .)
    +               reduce using rule 30 (local_decl -> var_decl .)
    -               reduce using rule 30 (local_decl -> var_decl .)
    !               reduce using rule 30 (local_decl -> var_decl .)
    }               reduce using rule 30 (local_decl -> var_decl .)


state 113

    (62) expr -> IDENT ( args ) .
    ]               reduce using rule 62 (expr -> IDENT ( args ) .)
    %               reduce using rule 62 (expr -> IDENT ( args ) .)
    /               reduce using rule 62 (expr -> IDENT ( args ) .)
    *               reduce using rule 62 (expr -> IDENT ( args ) .)
    -               reduce using rule 62 (expr -> IDENT ( args ) .)
    +               reduce using rule 62 (expr -> IDENT ( args ) .)
    >               reduce using rule 62 (expr -> IDENT ( args ) .)
    GE              reduce using rule 62 (expr -> IDENT ( args ) .)
    <               reduce using rule 62 (expr -> IDENT ( args ) .)
    LE              reduce using rule 62 (expr -> IDENT ( args ) .)
    NE              reduce using rule 62 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 62 (expr -> IDENT ( args ) .)
    AND             reduce using rule 62 (expr -> IDENT ( args ) .)
    OR              reduce using rule 62 (expr -> IDENT ( args ) .)
    ;               reduce using rule 62 (expr -> IDENT ( args ) .)
    )               reduce using rule 62 (expr -> IDENT ( args ) .)
    ,               reduce using rule 62 (expr -> IDENT ( args ) .)


state 114

    (88) arg_list -> arg_list , . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 139

state 115

    (63) expr -> IDENT [ expr ] .
    (64) expr -> IDENT [ expr ] . = expr
    ]               reduce using rule 63 (expr -> IDENT [ expr ] .)
    %               reduce using rule 63 (expr -> IDENT [ expr ] .)
    /               reduce using rule 63 (expr -> IDENT [ expr ] .)
    *               reduce using rule 63 (expr -> IDENT [ expr ] .)
    -               reduce using rule 63 (expr -> IDENT [ expr ] .)
    +               reduce using rule 63 (expr -> IDENT [ expr ] .)
    >               reduce using rule 63 (expr -> IDENT [ expr ] .)
    GE              reduce using rule 63 (expr -> IDENT [ expr ] .)
    <               reduce using rule 63 (expr -> IDENT [ expr ] .)
    LE              reduce using rule 63 (expr -> IDENT [ expr ] .)
    NE              reduce using rule 63 (expr -> IDENT [ expr ] .)
    EQ              reduce using rule 63 (expr -> IDENT [ expr ] .)
    AND             reduce using rule 63 (expr -> IDENT [ expr ] .)
    OR              reduce using rule 63 (expr -> IDENT [ expr ] .)
    ;               reduce using rule 63 (expr -> IDENT [ expr ] .)
    )               reduce using rule 63 (expr -> IDENT [ expr ] .)
    ,               reduce using rule 63 (expr -> IDENT [ expr ] .)
    =               shift and go to state 140


state 116

    (55) expr -> NEW type_spec [ expr . ]
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               shift and go to state 141
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 117

    (85) expr -> ( type_spec ) expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 85 (expr -> ( type_spec ) expr .)
    %               reduce using rule 85 (expr -> ( type_spec ) expr .)
    /               reduce using rule 85 (expr -> ( type_spec ) expr .)
    *               reduce using rule 85 (expr -> ( type_spec ) expr .)
    -               reduce using rule 85 (expr -> ( type_spec ) expr .)
    +               reduce using rule 85 (expr -> ( type_spec ) expr .)
    >               reduce using rule 85 (expr -> ( type_spec ) expr .)
    GE              reduce using rule 85 (expr -> ( type_spec ) expr .)
    <               reduce using rule 85 (expr -> ( type_spec ) expr .)
    LE              reduce using rule 85 (expr -> ( type_spec ) expr .)
    NE              reduce using rule 85 (expr -> ( type_spec ) expr .)
    EQ              reduce using rule 85 (expr -> ( type_spec ) expr .)
    AND             reduce using rule 85 (expr -> ( type_spec ) expr .)
    OR              reduce using rule 85 (expr -> ( type_spec ) expr .)
    ;               reduce using rule 85 (expr -> ( type_spec ) expr .)
    )               reduce using rule 85 (expr -> ( type_spec ) expr .)
    ,               reduce using rule 85 (expr -> ( type_spec ) expr .)


state 118

    (27) compound_stmt -> { local_decls stmt_list . }
    }               shift and go to state 142


state 119

    (31) stmt_list -> empty .
    }               reduce using rule 31 (stmt_list -> empty .)


state 120

    (32) stmt_list -> stmt . stmt_list
    (31) stmt_list -> . empty
    (32) stmt_list -> . stmt stmt_list
    (90) empty -> .
    (33) stmt -> . break_stmt
    (34) stmt -> . return_stmt
    (35) stmt -> . for_stmt
    (36) stmt -> . while_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . compound_stmt
    (39) stmt -> . expr_stmt
    (53) break_stmt -> . CONTINUE ;
    (54) break_stmt -> . BREAK ;
    (52) return_stmt -> . RETURN expr ;
    (49) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (48) while_stmt -> . WHILE ( expr ) stmt
    (50) if_stmt -> . IF ( expr ) stmt
    (51) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    (43) expr_stmt -> . SCANF ( expr , args ) ;
    (44) expr_stmt -> . PRINTF ( expr ) ;
    (45) expr_stmt -> . PRINTF ( expr , args ) ;
    (46) expr_stmt -> . ;
    (47) expr_stmt -> . expr ;
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    }               reduce using rule 90 (empty -> .)
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 130
    RETURN          shift and go to state 131
    FOR             shift and go to state 133
    WHILE           shift and go to state 134
    IF              shift and go to state 135
    {               shift and go to state 81
    SCANF           shift and go to state 136
    PRINTF          shift and go to state 137
    ;               shift and go to state 129
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    stmt                           shift and go to state 120
    stmt_list                      shift and go to state 143
    empty                          shift and go to state 119
    break_stmt                     shift and go to state 121
    return_stmt                    shift and go to state 122
    for_stmt                       shift and go to state 123
    while_stmt                     shift and go to state 124
    if_stmt                        shift and go to state 125
    compound_stmt                  shift and go to state 126
    expr_stmt                      shift and go to state 127
    expr                           shift and go to state 132

state 121

    (33) stmt -> break_stmt .
    CONTINUE        reduce using rule 33 (stmt -> break_stmt .)
    BREAK           reduce using rule 33 (stmt -> break_stmt .)
    RETURN          reduce using rule 33 (stmt -> break_stmt .)
    FOR             reduce using rule 33 (stmt -> break_stmt .)
    WHILE           reduce using rule 33 (stmt -> break_stmt .)
    IF              reduce using rule 33 (stmt -> break_stmt .)
    {               reduce using rule 33 (stmt -> break_stmt .)
    SCANF           reduce using rule 33 (stmt -> break_stmt .)
    PRINTF          reduce using rule 33 (stmt -> break_stmt .)
    ;               reduce using rule 33 (stmt -> break_stmt .)
    NEW             reduce using rule 33 (stmt -> break_stmt .)
    CHAR_LIT        reduce using rule 33 (stmt -> break_stmt .)
    STRING_LIT      reduce using rule 33 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 33 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 33 (stmt -> break_stmt .)
    BOOL_LIT        reduce using rule 33 (stmt -> break_stmt .)
    IDENT           reduce using rule 33 (stmt -> break_stmt .)
    NULL            reduce using rule 33 (stmt -> break_stmt .)
    (               reduce using rule 33 (stmt -> break_stmt .)
    +               reduce using rule 33 (stmt -> break_stmt .)
    -               reduce using rule 33 (stmt -> break_stmt .)
    !               reduce using rule 33 (stmt -> break_stmt .)
    }               reduce using rule 33 (stmt -> break_stmt .)
    ELSE            reduce using rule 33 (stmt -> break_stmt .)


state 122

    (34) stmt -> return_stmt .
    CONTINUE        reduce using rule 34 (stmt -> return_stmt .)
    BREAK           reduce using rule 34 (stmt -> return_stmt .)
    RETURN          reduce using rule 34 (stmt -> return_stmt .)
    FOR             reduce using rule 34 (stmt -> return_stmt .)
    WHILE           reduce using rule 34 (stmt -> return_stmt .)
    IF              reduce using rule 34 (stmt -> return_stmt .)
    {               reduce using rule 34 (stmt -> return_stmt .)
    SCANF           reduce using rule 34 (stmt -> return_stmt .)
    PRINTF          reduce using rule 34 (stmt -> return_stmt .)
    ;               reduce using rule 34 (stmt -> return_stmt .)
    NEW             reduce using rule 34 (stmt -> return_stmt .)
    CHAR_LIT        reduce using rule 34 (stmt -> return_stmt .)
    STRING_LIT      reduce using rule 34 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 34 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 34 (stmt -> return_stmt .)
    BOOL_LIT        reduce using rule 34 (stmt -> return_stmt .)
    IDENT           reduce using rule 34 (stmt -> return_stmt .)
    NULL            reduce using rule 34 (stmt -> return_stmt .)
    (               reduce using rule 34 (stmt -> return_stmt .)
    +               reduce using rule 34 (stmt -> return_stmt .)
    -               reduce using rule 34 (stmt -> return_stmt .)
    !               reduce using rule 34 (stmt -> return_stmt .)
    }               reduce using rule 34 (stmt -> return_stmt .)
    ELSE            reduce using rule 34 (stmt -> return_stmt .)


state 123

    (35) stmt -> for_stmt .
    CONTINUE        reduce using rule 35 (stmt -> for_stmt .)
    BREAK           reduce using rule 35 (stmt -> for_stmt .)
    RETURN          reduce using rule 35 (stmt -> for_stmt .)
    FOR             reduce using rule 35 (stmt -> for_stmt .)
    WHILE           reduce using rule 35 (stmt -> for_stmt .)
    IF              reduce using rule 35 (stmt -> for_stmt .)
    {               reduce using rule 35 (stmt -> for_stmt .)
    SCANF           reduce using rule 35 (stmt -> for_stmt .)
    PRINTF          reduce using rule 35 (stmt -> for_stmt .)
    ;               reduce using rule 35 (stmt -> for_stmt .)
    NEW             reduce using rule 35 (stmt -> for_stmt .)
    CHAR_LIT        reduce using rule 35 (stmt -> for_stmt .)
    STRING_LIT      reduce using rule 35 (stmt -> for_stmt .)
    FLOAT_LIT       reduce using rule 35 (stmt -> for_stmt .)
    INT_LIT         reduce using rule 35 (stmt -> for_stmt .)
    BOOL_LIT        reduce using rule 35 (stmt -> for_stmt .)
    IDENT           reduce using rule 35 (stmt -> for_stmt .)
    NULL            reduce using rule 35 (stmt -> for_stmt .)
    (               reduce using rule 35 (stmt -> for_stmt .)
    +               reduce using rule 35 (stmt -> for_stmt .)
    -               reduce using rule 35 (stmt -> for_stmt .)
    !               reduce using rule 35 (stmt -> for_stmt .)
    }               reduce using rule 35 (stmt -> for_stmt .)
    ELSE            reduce using rule 35 (stmt -> for_stmt .)


state 124

    (36) stmt -> while_stmt .
    CONTINUE        reduce using rule 36 (stmt -> while_stmt .)
    BREAK           reduce using rule 36 (stmt -> while_stmt .)
    RETURN          reduce using rule 36 (stmt -> while_stmt .)
    FOR             reduce using rule 36 (stmt -> while_stmt .)
    WHILE           reduce using rule 36 (stmt -> while_stmt .)
    IF              reduce using rule 36 (stmt -> while_stmt .)
    {               reduce using rule 36 (stmt -> while_stmt .)
    SCANF           reduce using rule 36 (stmt -> while_stmt .)
    PRINTF          reduce using rule 36 (stmt -> while_stmt .)
    ;               reduce using rule 36 (stmt -> while_stmt .)
    NEW             reduce using rule 36 (stmt -> while_stmt .)
    CHAR_LIT        reduce using rule 36 (stmt -> while_stmt .)
    STRING_LIT      reduce using rule 36 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 36 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 36 (stmt -> while_stmt .)
    BOOL_LIT        reduce using rule 36 (stmt -> while_stmt .)
    IDENT           reduce using rule 36 (stmt -> while_stmt .)
    NULL            reduce using rule 36 (stmt -> while_stmt .)
    (               reduce using rule 36 (stmt -> while_stmt .)
    +               reduce using rule 36 (stmt -> while_stmt .)
    -               reduce using rule 36 (stmt -> while_stmt .)
    !               reduce using rule 36 (stmt -> while_stmt .)
    }               reduce using rule 36 (stmt -> while_stmt .)
    ELSE            reduce using rule 36 (stmt -> while_stmt .)


state 125

    (37) stmt -> if_stmt .
    CONTINUE        reduce using rule 37 (stmt -> if_stmt .)
    BREAK           reduce using rule 37 (stmt -> if_stmt .)
    RETURN          reduce using rule 37 (stmt -> if_stmt .)
    FOR             reduce using rule 37 (stmt -> if_stmt .)
    WHILE           reduce using rule 37 (stmt -> if_stmt .)
    IF              reduce using rule 37 (stmt -> if_stmt .)
    {               reduce using rule 37 (stmt -> if_stmt .)
    SCANF           reduce using rule 37 (stmt -> if_stmt .)
    PRINTF          reduce using rule 37 (stmt -> if_stmt .)
    ;               reduce using rule 37 (stmt -> if_stmt .)
    NEW             reduce using rule 37 (stmt -> if_stmt .)
    CHAR_LIT        reduce using rule 37 (stmt -> if_stmt .)
    STRING_LIT      reduce using rule 37 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 37 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 37 (stmt -> if_stmt .)
    BOOL_LIT        reduce using rule 37 (stmt -> if_stmt .)
    IDENT           reduce using rule 37 (stmt -> if_stmt .)
    NULL            reduce using rule 37 (stmt -> if_stmt .)
    (               reduce using rule 37 (stmt -> if_stmt .)
    +               reduce using rule 37 (stmt -> if_stmt .)
    -               reduce using rule 37 (stmt -> if_stmt .)
    !               reduce using rule 37 (stmt -> if_stmt .)
    }               reduce using rule 37 (stmt -> if_stmt .)
    ELSE            reduce using rule 37 (stmt -> if_stmt .)


state 126

    (38) stmt -> compound_stmt .
    CONTINUE        reduce using rule 38 (stmt -> compound_stmt .)
    BREAK           reduce using rule 38 (stmt -> compound_stmt .)
    RETURN          reduce using rule 38 (stmt -> compound_stmt .)
    FOR             reduce using rule 38 (stmt -> compound_stmt .)
    WHILE           reduce using rule 38 (stmt -> compound_stmt .)
    IF              reduce using rule 38 (stmt -> compound_stmt .)
    {               reduce using rule 38 (stmt -> compound_stmt .)
    SCANF           reduce using rule 38 (stmt -> compound_stmt .)
    PRINTF          reduce using rule 38 (stmt -> compound_stmt .)
    ;               reduce using rule 38 (stmt -> compound_stmt .)
    NEW             reduce using rule 38 (stmt -> compound_stmt .)
    CHAR_LIT        reduce using rule 38 (stmt -> compound_stmt .)
    STRING_LIT      reduce using rule 38 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 38 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 38 (stmt -> compound_stmt .)
    BOOL_LIT        reduce using rule 38 (stmt -> compound_stmt .)
    IDENT           reduce using rule 38 (stmt -> compound_stmt .)
    NULL            reduce using rule 38 (stmt -> compound_stmt .)
    (               reduce using rule 38 (stmt -> compound_stmt .)
    +               reduce using rule 38 (stmt -> compound_stmt .)
    -               reduce using rule 38 (stmt -> compound_stmt .)
    !               reduce using rule 38 (stmt -> compound_stmt .)
    }               reduce using rule 38 (stmt -> compound_stmt .)
    ELSE            reduce using rule 38 (stmt -> compound_stmt .)


state 127

    (39) stmt -> expr_stmt .
    CONTINUE        reduce using rule 39 (stmt -> expr_stmt .)
    BREAK           reduce using rule 39 (stmt -> expr_stmt .)
    RETURN          reduce using rule 39 (stmt -> expr_stmt .)
    FOR             reduce using rule 39 (stmt -> expr_stmt .)
    WHILE           reduce using rule 39 (stmt -> expr_stmt .)
    IF              reduce using rule 39 (stmt -> expr_stmt .)
    {               reduce using rule 39 (stmt -> expr_stmt .)
    SCANF           reduce using rule 39 (stmt -> expr_stmt .)
    PRINTF          reduce using rule 39 (stmt -> expr_stmt .)
    ;               reduce using rule 39 (stmt -> expr_stmt .)
    NEW             reduce using rule 39 (stmt -> expr_stmt .)
    CHAR_LIT        reduce using rule 39 (stmt -> expr_stmt .)
    STRING_LIT      reduce using rule 39 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 39 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 39 (stmt -> expr_stmt .)
    BOOL_LIT        reduce using rule 39 (stmt -> expr_stmt .)
    IDENT           reduce using rule 39 (stmt -> expr_stmt .)
    NULL            reduce using rule 39 (stmt -> expr_stmt .)
    (               reduce using rule 39 (stmt -> expr_stmt .)
    +               reduce using rule 39 (stmt -> expr_stmt .)
    -               reduce using rule 39 (stmt -> expr_stmt .)
    !               reduce using rule 39 (stmt -> expr_stmt .)
    }               reduce using rule 39 (stmt -> expr_stmt .)
    ELSE            reduce using rule 39 (stmt -> expr_stmt .)


state 128

    (53) break_stmt -> CONTINUE . ;
    ;               shift and go to state 144


state 129

    (46) expr_stmt -> ; .
    CONTINUE        reduce using rule 46 (expr_stmt -> ; .)
    BREAK           reduce using rule 46 (expr_stmt -> ; .)
    RETURN          reduce using rule 46 (expr_stmt -> ; .)
    FOR             reduce using rule 46 (expr_stmt -> ; .)
    WHILE           reduce using rule 46 (expr_stmt -> ; .)
    IF              reduce using rule 46 (expr_stmt -> ; .)
    {               reduce using rule 46 (expr_stmt -> ; .)
    SCANF           reduce using rule 46 (expr_stmt -> ; .)
    PRINTF          reduce using rule 46 (expr_stmt -> ; .)
    ;               reduce using rule 46 (expr_stmt -> ; .)
    NEW             reduce using rule 46 (expr_stmt -> ; .)
    CHAR_LIT        reduce using rule 46 (expr_stmt -> ; .)
    STRING_LIT      reduce using rule 46 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 46 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 46 (expr_stmt -> ; .)
    BOOL_LIT        reduce using rule 46 (expr_stmt -> ; .)
    IDENT           reduce using rule 46 (expr_stmt -> ; .)
    NULL            reduce using rule 46 (expr_stmt -> ; .)
    (               reduce using rule 46 (expr_stmt -> ; .)
    +               reduce using rule 46 (expr_stmt -> ; .)
    -               reduce using rule 46 (expr_stmt -> ; .)
    !               reduce using rule 46 (expr_stmt -> ; .)
    }               reduce using rule 46 (expr_stmt -> ; .)
    ELSE            reduce using rule 46 (expr_stmt -> ; .)


state 130

    (54) break_stmt -> BREAK . ;
    ;               shift and go to state 145


state 131

    (52) return_stmt -> RETURN . expr ;
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 146

state 132

    (47) expr_stmt -> expr . ;
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ;               shift and go to state 147
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 133

    (49) for_stmt -> FOR . ( expr ; expr ; expr ) stmt
    (               shift and go to state 148


state 134

    (48) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 149


state 135

    (50) if_stmt -> IF . ( expr ) stmt
    (51) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (               shift and go to state 150


state 136

    (43) expr_stmt -> SCANF . ( expr , args ) ;
    (               shift and go to state 151


state 137

    (44) expr_stmt -> PRINTF . ( expr ) ;
    (45) expr_stmt -> PRINTF . ( expr , args ) ;
    (               shift and go to state 152


state 138

    (29) local_decls -> local_decl local_decls .
    CONTINUE        reduce using rule 29 (local_decls -> local_decl local_decls .)
    BREAK           reduce using rule 29 (local_decls -> local_decl local_decls .)
    RETURN          reduce using rule 29 (local_decls -> local_decl local_decls .)
    FOR             reduce using rule 29 (local_decls -> local_decl local_decls .)
    WHILE           reduce using rule 29 (local_decls -> local_decl local_decls .)
    IF              reduce using rule 29 (local_decls -> local_decl local_decls .)
    {               reduce using rule 29 (local_decls -> local_decl local_decls .)
    SCANF           reduce using rule 29 (local_decls -> local_decl local_decls .)
    PRINTF          reduce using rule 29 (local_decls -> local_decl local_decls .)
    ;               reduce using rule 29 (local_decls -> local_decl local_decls .)
    NEW             reduce using rule 29 (local_decls -> local_decl local_decls .)
    CHAR_LIT        reduce using rule 29 (local_decls -> local_decl local_decls .)
    STRING_LIT      reduce using rule 29 (local_decls -> local_decl local_decls .)
    FLOAT_LIT       reduce using rule 29 (local_decls -> local_decl local_decls .)
    INT_LIT         reduce using rule 29 (local_decls -> local_decl local_decls .)
    BOOL_LIT        reduce using rule 29 (local_decls -> local_decl local_decls .)
    IDENT           reduce using rule 29 (local_decls -> local_decl local_decls .)
    NULL            reduce using rule 29 (local_decls -> local_decl local_decls .)
    (               reduce using rule 29 (local_decls -> local_decl local_decls .)
    +               reduce using rule 29 (local_decls -> local_decl local_decls .)
    -               reduce using rule 29 (local_decls -> local_decl local_decls .)
    !               reduce using rule 29 (local_decls -> local_decl local_decls .)
    }               reduce using rule 29 (local_decls -> local_decl local_decls .)


state 139

    (88) arg_list -> arg_list , expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ,               reduce using rule 88 (arg_list -> arg_list , expr .)
    )               reduce using rule 88 (arg_list -> arg_list , expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 140

    (64) expr -> IDENT [ expr ] = . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 153

state 141

    (55) expr -> NEW type_spec [ expr ] .
    ]               reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    %               reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    /               reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    *               reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    -               reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    +               reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    >               reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    GE              reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    <               reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    LE              reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    NE              reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    EQ              reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    AND             reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    OR              reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    ;               reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    )               reduce using rule 55 (expr -> NEW type_spec [ expr ] .)
    ,               reduce using rule 55 (expr -> NEW type_spec [ expr ] .)


state 142

    (27) compound_stmt -> { local_decls stmt_list } .
    CLASS           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    CHAR            reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    DOUBLE          reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    CONTINUE        reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    FOR             reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    SCANF           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    PRINTF          reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    NEW             reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    CHAR_LIT        reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    STRING_LIT      reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    BOOL_LIT        reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    NULL            reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)


state 143

    (32) stmt_list -> stmt stmt_list .
    }               reduce using rule 32 (stmt_list -> stmt stmt_list .)


state 144

    (53) break_stmt -> CONTINUE ; .
    CONTINUE        reduce using rule 53 (break_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 53 (break_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 53 (break_stmt -> CONTINUE ; .)
    FOR             reduce using rule 53 (break_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 53 (break_stmt -> CONTINUE ; .)
    IF              reduce using rule 53 (break_stmt -> CONTINUE ; .)
    {               reduce using rule 53 (break_stmt -> CONTINUE ; .)
    SCANF           reduce using rule 53 (break_stmt -> CONTINUE ; .)
    PRINTF          reduce using rule 53 (break_stmt -> CONTINUE ; .)
    ;               reduce using rule 53 (break_stmt -> CONTINUE ; .)
    NEW             reduce using rule 53 (break_stmt -> CONTINUE ; .)
    CHAR_LIT        reduce using rule 53 (break_stmt -> CONTINUE ; .)
    STRING_LIT      reduce using rule 53 (break_stmt -> CONTINUE ; .)
    FLOAT_LIT       reduce using rule 53 (break_stmt -> CONTINUE ; .)
    INT_LIT         reduce using rule 53 (break_stmt -> CONTINUE ; .)
    BOOL_LIT        reduce using rule 53 (break_stmt -> CONTINUE ; .)
    IDENT           reduce using rule 53 (break_stmt -> CONTINUE ; .)
    NULL            reduce using rule 53 (break_stmt -> CONTINUE ; .)
    (               reduce using rule 53 (break_stmt -> CONTINUE ; .)
    +               reduce using rule 53 (break_stmt -> CONTINUE ; .)
    -               reduce using rule 53 (break_stmt -> CONTINUE ; .)
    !               reduce using rule 53 (break_stmt -> CONTINUE ; .)
    }               reduce using rule 53 (break_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 53 (break_stmt -> CONTINUE ; .)


state 145

    (54) break_stmt -> BREAK ; .
    CONTINUE        reduce using rule 54 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 54 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 54 (break_stmt -> BREAK ; .)
    FOR             reduce using rule 54 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 54 (break_stmt -> BREAK ; .)
    IF              reduce using rule 54 (break_stmt -> BREAK ; .)
    {               reduce using rule 54 (break_stmt -> BREAK ; .)
    SCANF           reduce using rule 54 (break_stmt -> BREAK ; .)
    PRINTF          reduce using rule 54 (break_stmt -> BREAK ; .)
    ;               reduce using rule 54 (break_stmt -> BREAK ; .)
    NEW             reduce using rule 54 (break_stmt -> BREAK ; .)
    CHAR_LIT        reduce using rule 54 (break_stmt -> BREAK ; .)
    STRING_LIT      reduce using rule 54 (break_stmt -> BREAK ; .)
    FLOAT_LIT       reduce using rule 54 (break_stmt -> BREAK ; .)
    INT_LIT         reduce using rule 54 (break_stmt -> BREAK ; .)
    BOOL_LIT        reduce using rule 54 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 54 (break_stmt -> BREAK ; .)
    NULL            reduce using rule 54 (break_stmt -> BREAK ; .)
    (               reduce using rule 54 (break_stmt -> BREAK ; .)
    +               reduce using rule 54 (break_stmt -> BREAK ; .)
    -               reduce using rule 54 (break_stmt -> BREAK ; .)
    !               reduce using rule 54 (break_stmt -> BREAK ; .)
    }               reduce using rule 54 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 54 (break_stmt -> BREAK ; .)


state 146

    (52) return_stmt -> RETURN expr . ;
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ;               shift and go to state 154
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 147

    (47) expr_stmt -> expr ; .
    CONTINUE        reduce using rule 47 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 47 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 47 (expr_stmt -> expr ; .)
    FOR             reduce using rule 47 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 47 (expr_stmt -> expr ; .)
    IF              reduce using rule 47 (expr_stmt -> expr ; .)
    {               reduce using rule 47 (expr_stmt -> expr ; .)
    SCANF           reduce using rule 47 (expr_stmt -> expr ; .)
    PRINTF          reduce using rule 47 (expr_stmt -> expr ; .)
    ;               reduce using rule 47 (expr_stmt -> expr ; .)
    NEW             reduce using rule 47 (expr_stmt -> expr ; .)
    CHAR_LIT        reduce using rule 47 (expr_stmt -> expr ; .)
    STRING_LIT      reduce using rule 47 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 47 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 47 (expr_stmt -> expr ; .)
    BOOL_LIT        reduce using rule 47 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 47 (expr_stmt -> expr ; .)
    NULL            reduce using rule 47 (expr_stmt -> expr ; .)
    (               reduce using rule 47 (expr_stmt -> expr ; .)
    +               reduce using rule 47 (expr_stmt -> expr ; .)
    -               reduce using rule 47 (expr_stmt -> expr ; .)
    !               reduce using rule 47 (expr_stmt -> expr ; .)
    }               reduce using rule 47 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 47 (expr_stmt -> expr ; .)


state 148

    (49) for_stmt -> FOR ( . expr ; expr ; expr ) stmt
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 155

state 149

    (48) while_stmt -> WHILE ( . expr ) stmt
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 156

state 150

    (50) if_stmt -> IF ( . expr ) stmt
    (51) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 157

state 151

    (43) expr_stmt -> SCANF ( . expr , args ) ;
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 158

state 152

    (44) expr_stmt -> PRINTF ( . expr ) ;
    (45) expr_stmt -> PRINTF ( . expr , args ) ;
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 159

state 153

    (64) expr -> IDENT [ expr ] = expr .
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ]               reduce using rule 64 (expr -> IDENT [ expr ] = expr .)
    ;               reduce using rule 64 (expr -> IDENT [ expr ] = expr .)
    )               reduce using rule 64 (expr -> IDENT [ expr ] = expr .)
    ,               reduce using rule 64 (expr -> IDENT [ expr ] = expr .)
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 154

    (52) return_stmt -> RETURN expr ; .
    CONTINUE        reduce using rule 52 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 52 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 52 (return_stmt -> RETURN expr ; .)
    FOR             reduce using rule 52 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 52 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 52 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    SCANF           reduce using rule 52 (return_stmt -> RETURN expr ; .)
    PRINTF          reduce using rule 52 (return_stmt -> RETURN expr ; .)
    ;               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    NEW             reduce using rule 52 (return_stmt -> RETURN expr ; .)
    CHAR_LIT        reduce using rule 52 (return_stmt -> RETURN expr ; .)
    STRING_LIT      reduce using rule 52 (return_stmt -> RETURN expr ; .)
    FLOAT_LIT       reduce using rule 52 (return_stmt -> RETURN expr ; .)
    INT_LIT         reduce using rule 52 (return_stmt -> RETURN expr ; .)
    BOOL_LIT        reduce using rule 52 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 52 (return_stmt -> RETURN expr ; .)
    NULL            reduce using rule 52 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    }               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 52 (return_stmt -> RETURN expr ; .)


state 155

    (49) for_stmt -> FOR ( expr . ; expr ; expr ) stmt
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ;               shift and go to state 160
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 156

    (48) while_stmt -> WHILE ( expr . ) stmt
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    )               shift and go to state 161
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 157

    (50) if_stmt -> IF ( expr . ) stmt
    (51) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    )               shift and go to state 162
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 158

    (43) expr_stmt -> SCANF ( expr . , args ) ;
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ,               shift and go to state 163
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 159

    (44) expr_stmt -> PRINTF ( expr . ) ;
    (45) expr_stmt -> PRINTF ( expr . , args ) ;
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    )               shift and go to state 164
    ,               shift and go to state 165
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 160

    (49) for_stmt -> FOR ( expr ; . expr ; expr ) stmt
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 166

state 161

    (48) while_stmt -> WHILE ( expr ) . stmt
    (33) stmt -> . break_stmt
    (34) stmt -> . return_stmt
    (35) stmt -> . for_stmt
    (36) stmt -> . while_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . compound_stmt
    (39) stmt -> . expr_stmt
    (53) break_stmt -> . CONTINUE ;
    (54) break_stmt -> . BREAK ;
    (52) return_stmt -> . RETURN expr ;
    (49) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (48) while_stmt -> . WHILE ( expr ) stmt
    (50) if_stmt -> . IF ( expr ) stmt
    (51) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    (43) expr_stmt -> . SCANF ( expr , args ) ;
    (44) expr_stmt -> . PRINTF ( expr ) ;
    (45) expr_stmt -> . PRINTF ( expr , args ) ;
    (46) expr_stmt -> . ;
    (47) expr_stmt -> . expr ;
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 130
    RETURN          shift and go to state 131
    FOR             shift and go to state 133
    WHILE           shift and go to state 134
    IF              shift and go to state 135
    {               shift and go to state 81
    SCANF           shift and go to state 136
    PRINTF          shift and go to state 137
    ;               shift and go to state 129
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 132
    stmt                           shift and go to state 167
    break_stmt                     shift and go to state 121
    return_stmt                    shift and go to state 122
    for_stmt                       shift and go to state 123
    while_stmt                     shift and go to state 124
    if_stmt                        shift and go to state 125
    compound_stmt                  shift and go to state 126
    expr_stmt                      shift and go to state 127

state 162

    (50) if_stmt -> IF ( expr ) . stmt
    (51) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (33) stmt -> . break_stmt
    (34) stmt -> . return_stmt
    (35) stmt -> . for_stmt
    (36) stmt -> . while_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . compound_stmt
    (39) stmt -> . expr_stmt
    (53) break_stmt -> . CONTINUE ;
    (54) break_stmt -> . BREAK ;
    (52) return_stmt -> . RETURN expr ;
    (49) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (48) while_stmt -> . WHILE ( expr ) stmt
    (50) if_stmt -> . IF ( expr ) stmt
    (51) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    (43) expr_stmt -> . SCANF ( expr , args ) ;
    (44) expr_stmt -> . PRINTF ( expr ) ;
    (45) expr_stmt -> . PRINTF ( expr , args ) ;
    (46) expr_stmt -> . ;
    (47) expr_stmt -> . expr ;
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 130
    RETURN          shift and go to state 131
    FOR             shift and go to state 133
    WHILE           shift and go to state 134
    IF              shift and go to state 135
    {               shift and go to state 81
    SCANF           shift and go to state 136
    PRINTF          shift and go to state 137
    ;               shift and go to state 129
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 132
    stmt                           shift and go to state 168
    break_stmt                     shift and go to state 121
    return_stmt                    shift and go to state 122
    for_stmt                       shift and go to state 123
    while_stmt                     shift and go to state 124
    if_stmt                        shift and go to state 125
    compound_stmt                  shift and go to state 126
    expr_stmt                      shift and go to state 127

state 163

    (43) expr_stmt -> SCANF ( expr , . args ) ;
    (86) args -> . empty
    (87) args -> . arg_list
    (90) empty -> .
    (88) arg_list -> . arg_list , expr
    (89) arg_list -> . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    )               reduce using rule 90 (empty -> .)
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 88
    args                           shift and go to state 169
    empty                          shift and go to state 86
    arg_list                       shift and go to state 87

state 164

    (44) expr_stmt -> PRINTF ( expr ) . ;
    ;               shift and go to state 170


state 165

    (45) expr_stmt -> PRINTF ( expr , . args ) ;
    (86) args -> . empty
    (87) args -> . arg_list
    (90) empty -> .
    (88) arg_list -> . arg_list , expr
    (89) arg_list -> . expr
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    )               reduce using rule 90 (empty -> .)
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 88
    args                           shift and go to state 171
    empty                          shift and go to state 86
    arg_list                       shift and go to state 87

state 166

    (49) for_stmt -> FOR ( expr ; expr . ; expr ) stmt
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    ;               shift and go to state 172
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 167

    (48) while_stmt -> WHILE ( expr ) stmt .
    CONTINUE        reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    SCANF           reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    PRINTF          reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    CHAR_LIT        reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    STRING_LIT      reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    INT_LIT         reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL_LIT        reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    NULL            reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    }               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)


state 168

    (50) if_stmt -> IF ( expr ) stmt .
    (51) if_stmt -> IF ( expr ) stmt . ELSE stmt
    CONTINUE        reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    SCANF           reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    PRINTF          reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    CHAR_LIT        reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    STRING_LIT      reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LIT        reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    NULL            reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    }               reduce using rule 50 (if_stmt -> IF ( expr ) stmt .)
    ELSE            shift and go to state 173


state 169

    (43) expr_stmt -> SCANF ( expr , args . ) ;
    )               shift and go to state 174


state 170

    (44) expr_stmt -> PRINTF ( expr ) ; .
    CONTINUE        reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    BREAK           reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    RETURN          reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    FOR             reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    WHILE           reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    IF              reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    {               reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    SCANF           reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    PRINTF          reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    ;               reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    NEW             reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    CHAR_LIT        reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    STRING_LIT      reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    FLOAT_LIT       reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    INT_LIT         reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    BOOL_LIT        reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    IDENT           reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    NULL            reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    (               reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    +               reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    -               reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    !               reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    }               reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)
    ELSE            reduce using rule 44 (expr_stmt -> PRINTF ( expr ) ; .)


state 171

    (45) expr_stmt -> PRINTF ( expr , args . ) ;
    )               shift and go to state 175


state 172

    (49) for_stmt -> FOR ( expr ; expr ; . expr ) stmt
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 176

state 173

    (51) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (33) stmt -> . break_stmt
    (34) stmt -> . return_stmt
    (35) stmt -> . for_stmt
    (36) stmt -> . while_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . compound_stmt
    (39) stmt -> . expr_stmt
    (53) break_stmt -> . CONTINUE ;
    (54) break_stmt -> . BREAK ;
    (52) return_stmt -> . RETURN expr ;
    (49) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (48) while_stmt -> . WHILE ( expr ) stmt
    (50) if_stmt -> . IF ( expr ) stmt
    (51) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    (43) expr_stmt -> . SCANF ( expr , args ) ;
    (44) expr_stmt -> . PRINTF ( expr ) ;
    (45) expr_stmt -> . PRINTF ( expr , args ) ;
    (46) expr_stmt -> . ;
    (47) expr_stmt -> . expr ;
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 130
    RETURN          shift and go to state 131
    FOR             shift and go to state 133
    WHILE           shift and go to state 134
    IF              shift and go to state 135
    {               shift and go to state 81
    SCANF           shift and go to state 136
    PRINTF          shift and go to state 137
    ;               shift and go to state 129
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 132
    stmt                           shift and go to state 177
    break_stmt                     shift and go to state 121
    return_stmt                    shift and go to state 122
    for_stmt                       shift and go to state 123
    while_stmt                     shift and go to state 124
    if_stmt                        shift and go to state 125
    compound_stmt                  shift and go to state 126
    expr_stmt                      shift and go to state 127

state 174

    (43) expr_stmt -> SCANF ( expr , args ) . ;
    ;               shift and go to state 178


state 175

    (45) expr_stmt -> PRINTF ( expr , args ) . ;
    ;               shift and go to state 179


state 176

    (49) for_stmt -> FOR ( expr ; expr ; expr . ) stmt
    (72) expr -> expr . % expr
    (73) expr -> expr . / expr
    (74) expr -> expr . * expr
    (75) expr -> expr . - expr
    (76) expr -> expr . + expr
    (77) expr -> expr . > expr
    (78) expr -> expr . GE expr
    (79) expr -> expr . < expr
    (80) expr -> expr . LE expr
    (81) expr -> expr . NE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . AND expr
    (84) expr -> expr . OR expr
    )               shift and go to state 180
    %               shift and go to state 59
    /               shift and go to state 60
    *               shift and go to state 61
    -               shift and go to state 62
    +               shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    <               shift and go to state 66
    LE              shift and go to state 67
    NE              shift and go to state 68
    EQ              shift and go to state 69
    AND             shift and go to state 70
    OR              shift and go to state 71


state 177

    (51) if_stmt -> IF ( expr ) stmt ELSE stmt .
    CONTINUE        reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SCANF           reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINTF          reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CHAR_LIT        reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING_LIT      reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LIT        reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NULL            reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    }               reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 51 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


state 178

    (43) expr_stmt -> SCANF ( expr , args ) ; .
    CONTINUE        reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    BREAK           reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    RETURN          reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    FOR             reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    WHILE           reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    IF              reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    {               reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    SCANF           reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    PRINTF          reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    ;               reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    NEW             reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    CHAR_LIT        reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    STRING_LIT      reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    FLOAT_LIT       reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    INT_LIT         reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    BOOL_LIT        reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    IDENT           reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    NULL            reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    (               reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    +               reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    -               reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    !               reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    }               reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)
    ELSE            reduce using rule 43 (expr_stmt -> SCANF ( expr , args ) ; .)


state 179

    (45) expr_stmt -> PRINTF ( expr , args ) ; .
    CONTINUE        reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    BREAK           reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    RETURN          reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    FOR             reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    WHILE           reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    IF              reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    {               reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    SCANF           reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    PRINTF          reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    ;               reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    NEW             reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    CHAR_LIT        reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    STRING_LIT      reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    FLOAT_LIT       reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    INT_LIT         reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    BOOL_LIT        reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    IDENT           reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    NULL            reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    (               reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    +               reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    -               reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    !               reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    }               reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)
    ELSE            reduce using rule 45 (expr_stmt -> PRINTF ( expr , args ) ; .)


state 180

    (49) for_stmt -> FOR ( expr ; expr ; expr ) . stmt
    (33) stmt -> . break_stmt
    (34) stmt -> . return_stmt
    (35) stmt -> . for_stmt
    (36) stmt -> . while_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . compound_stmt
    (39) stmt -> . expr_stmt
    (53) break_stmt -> . CONTINUE ;
    (54) break_stmt -> . BREAK ;
    (52) return_stmt -> . RETURN expr ;
    (49) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (48) while_stmt -> . WHILE ( expr ) stmt
    (50) if_stmt -> . IF ( expr ) stmt
    (51) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    (43) expr_stmt -> . SCANF ( expr , args ) ;
    (44) expr_stmt -> . PRINTF ( expr ) ;
    (45) expr_stmt -> . PRINTF ( expr , args ) ;
    (46) expr_stmt -> . ;
    (47) expr_stmt -> . expr ;
    (55) expr -> . NEW type_spec [ expr ]
    (56) expr -> . CHAR_LIT
    (57) expr -> . STRING_LIT
    (58) expr -> . FLOAT_LIT
    (59) expr -> . INT_LIT
    (60) expr -> . BOOL_LIT
    (61) expr -> . IDENT . SIZE
    (62) expr -> . IDENT ( args )
    (63) expr -> . IDENT [ expr ]
    (64) expr -> . IDENT [ expr ] = expr
    (65) expr -> . IDENT = expr
    (66) expr -> . NULL
    (67) expr -> . IDENT
    (68) expr -> . ( expr )
    (69) expr -> . + expr
    (70) expr -> . - expr
    (71) expr -> . ! expr
    (72) expr -> . expr % expr
    (73) expr -> . expr / expr
    (74) expr -> . expr * expr
    (75) expr -> . expr - expr
    (76) expr -> . expr + expr
    (77) expr -> . expr > expr
    (78) expr -> . expr GE expr
    (79) expr -> . expr < expr
    (80) expr -> . expr LE expr
    (81) expr -> . expr NE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr AND expr
    (84) expr -> . expr OR expr
    (85) expr -> . ( type_spec ) expr
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 130
    RETURN          shift and go to state 131
    FOR             shift and go to state 133
    WHILE           shift and go to state 134
    IF              shift and go to state 135
    {               shift and go to state 81
    SCANF           shift and go to state 136
    PRINTF          shift and go to state 137
    ;               shift and go to state 129
    NEW             shift and go to state 33
    CHAR_LIT        shift and go to state 34
    STRING_LIT      shift and go to state 35
    FLOAT_LIT       shift and go to state 36
    INT_LIT         shift and go to state 37
    BOOL_LIT        shift and go to state 38
    IDENT           shift and go to state 31
    NULL            shift and go to state 40
    (               shift and go to state 39
    +               shift and go to state 41
    -               shift and go to state 42
    !               shift and go to state 43

    expr                           shift and go to state 132
    stmt                           shift and go to state 181
    break_stmt                     shift and go to state 121
    return_stmt                    shift and go to state 122
    for_stmt                       shift and go to state 123
    while_stmt                     shift and go to state 124
    if_stmt                        shift and go to state 125
    compound_stmt                  shift and go to state 126
    expr_stmt                      shift and go to state 127

state 181

    (49) for_stmt -> FOR ( expr ; expr ; expr ) stmt .
    CONTINUE        reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BREAK           reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    RETURN          reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FOR             reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    WHILE           reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IF              reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    {               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SCANF           reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PRINTF          reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ;               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    NEW             reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    CHAR_LIT        reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    STRING_LIT      reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FLOAT_LIT       reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    INT_LIT         reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BOOL_LIT        reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IDENT           reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    NULL            reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    (               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    +               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    -               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    !               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    }               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ELSE            reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
